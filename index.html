<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
   <head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Hypertext Transfer Protocol version 2.0</title><script>
var buttonsAdded = false;

function init() {
  var fb = document.createElement("div");
  fb.className = "feedback noprint";
  fb.setAttribute("onclick", "feedback();");
  fb.appendChild(document.createTextNode("feedback"));

  var bodyl = document.getElementsByTagName("body");
  bodyl.item(0).appendChild(fb);
}

function feedback() {
  toggleButtonsToElementsByName("h1");
  toggleButtonsToElementsByName("h2");
  toggleButtonsToElementsByName("h3");
  toggleButtonsToElementsByName("h4");

  buttonsAdded = !buttonsAdded;
}

function toggleButtonsToElementsByName(name) {
  var list = document.getElementsByTagName(name);
  for (var i = 0; i < list.length; i++) {
    toggleButton(list.item(i));
  }
}

function toggleButton(node) {
  if (! buttonsAdded) {

    // docname
    var template = "mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&body=<{ref}>:";

    var id = node.getAttribute("id");
    // better id available?
    var titlelinks = node.getElementsByTagName("a");
    for (var i = 0; i < titlelinks.length; i++) {
      var tl = titlelinks.item(i);
      if (tl.getAttribute("id")) {
        id = tl.getAttribute("id");
      }
    }

    // ref
    var ref = window.location.toString();
    var hash = ref.indexOf("#");
    if (hash != -1) {
      ref = ref.substring(0, hash);
    }
    if (id != "") {
      ref += "#" + id;
    }

    // docname
    var docname = "draft-ietf-httpbis-http2-latest";

    // section
    var section = node.textContent;
    section = section.replace("\u00a0", " ");

    // build URI from template
    var uri = template.replace("{docname}", encodeURIComponent(docname));
    uri = uri.replace("{section}", encodeURIComponent(section));
    uri = uri.replace("{ref}", encodeURIComponent(ref));

    var button = document.createElement("a");
    button.className = "fbbutton noprint";
    button.setAttribute("href", uri);
    button.appendChild(document.createTextNode("send feedback"));
    node.appendChild(button);
  }
  else {
    var buttons = node.getElementsByTagName("a");
    for (var i = 0; i < buttons.length; i++) {
      var b = buttons.item(i);
      if (b.className == "fbbutton noprint") {
        node.removeChild(b);
      }
    }
  }
}</script><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: cambria, helvetica, arial, sans-serif;
  font-size: 11pt;
  margin-right: 2em;
}
cite {
  font-style: normal;
}
dl {
  margin-left: 2em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 130%;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h2 {
  font-size: 120%;
  line-height: 15pt;
  page-break-after: avoid;
}
h3, h4, h5, h6 {
  font-size: 110%;
  page-break-after: avoid;
}
h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
}
ol {
  margin-left: 2em;
}
ol.la {
  list-style-type: lower-alpha;
}
ol.ua {
  list-style-type: upper-alpha;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
  page-break-inside: avoid;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
sup {
  font-size: 60%;
}
table {
  margin-left: 2em;
}
table.tt {
  vertical-align: top;
}
table.full {
  border-style: outset;
  border-width: 1px;
}
table.headers {
  border-style: outset;
  border-width: 1px;
}
table.tt td {
  vertical-align: top;
}
table.full td {
  border-style: inset;
  border-width: 1px;
}
table.tt th {
  vertical-align: top;
}
table.full th {
  border-style: inset;
  border-width: 1px;
}
table.headers th {
  border-style: none none inset none;
  border-width: 1px;
}
table.left {
  margin-right: auto;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
caption {
  caption-side: bottom;
  font-weight: bold;
  font-size: 10pt;
  margin-top: .5em;
}

table.header {
  border-spacing: 1px;
  width: 95%;
  font-size: 11pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap;
}
table.header td {
  background-color: gray;
  width: 50%;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc, ul.toc ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
}
ul.toc li {
  line-height: 150%;
  font-weight: bold;
  margin-left: 0em;
}
ul.toc li li {
  line-height: normal;
  font-weight: normal;
  font-size: 10pt;
  margin-left: 0em;
}
li.excluded {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}
.title, .filename, h1, h2, h3, h4 {
  font-family: candara, helvetica, arial, sans-serif;
}
samp, tt, code, pre {
  font: consolas, monospace;
}

.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 10pt;
}
.filename {
  color: #333333;
  font-size: 75%;
  font-weight: bold;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: green;
  font-size: 150%;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.warning {
  font-size: 130%;
  background-color: yellow;
}
.feedback {
  position: fixed;
  bottom: 1%;
  right: 1%;
  padding: 3px 5px;
  color: white;
  border-radius: 5px;
  background: #a00000;
  border: 1px solid silver;
}
.fbbutton {
  margin-left: 1em;
  color: #303030;
  font-size: small;
  font-weight: normal;
  background: #d0d000;
  padding: 1px 4px;
  border: 1px solid silver;
  border-radius: 5px;
}

@media print {
  .noprint {
    display: none;
  }

  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 110%;
  }

  ul.toc a:nth-child(2)::after {
    content: leader('.') target-counter(attr(href), page);
  }

  ul.ind li li a {
    content: target-counter(attr(href), page);
  }

  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "Internet-Draft";
  }
  @top-right {
       content: "October 2013";
  }
  @top-center {
       content: "HTTP/2.0";
  }
  @bottom-left {
       content: "Belshe, et al.";
  }
  @bottom-center {
       content: "Expires April 18, 2014";
  }
  @bottom-right {
       content: "[Page " counter(page) "]";
  }
}

@page:first {
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><style tyle="text/css">body {   font: 11pt cambria, helvetica, arial, sans-serif;   font-size-adjust: 0.5;   line-height: 130%;   margin: 1em auto;   max-width: 700px; }  .title, .filename, h1, h2, h3, h4 {   font-family: candara, helvetica, arial, sans-serif;   font-size-adjust: 0.5; } .title { font-size: 150%; } h1 { font-size: 130%; } h2 { font-size: 120%; } h3, h4 { font-size: 110%; } ul.toc >li { font-size: 95%; } ul.toc >li >ul, .figure, caption { font-size: 90%; }  table {   margin-left: 0em; } table.header {   width: 100%; }  table.header td {   background-color: inherit;   color: black; }  samp, tt, code, pre {   font: 11pt consolas, monospace;   font-size-adjust: none; }  pre.text, pre.text2 {   width: 90%; }  dt {   float: left; clear: left;   margin: 0.5em 0.5em 0 0; } dt:first-child {   margin-top: 0; } dd {   margin: 0.5em 0 0 2em; } dd p, dd ul {   margin-top: 0; margin-bottom: 0; } dd *+p {   margin-top: 0.5em; }  ol, ul {   padding: 0;   margin: 0.5em 0 0.5em 2em; } ul.toc, ul.toc ul {    margin: 0 0 0 1.5em; } ul.toc a:first-child {    display: inline-block;    min-width: 1.2em; }</style><link rel="Contents" href="#rfc.toc">
      <link rel="Author" href="#rfc.authors">
      <link rel="Copyright" href="#rfc.copyrightnotice">
      <link rel="Chapter" title="1 Introduction" href="#rfc.section.1">
      <link rel="Chapter" title="2 HTTP/2.0 Protocol Overview" href="#rfc.section.2">
      <link rel="Chapter" title="3 Starting HTTP/2.0" href="#rfc.section.3">
      <link rel="Chapter" title="4 HTTP Frames" href="#rfc.section.4">
      <link rel="Chapter" title="5 Streams and Multiplexing" href="#rfc.section.5">
      <link rel="Chapter" title="6 Frame Definitions" href="#rfc.section.6">
      <link rel="Chapter" title="7 Error Codes" href="#rfc.section.7">
      <link rel="Chapter" title="8 HTTP Message Exchanges" href="#rfc.section.8">
      <link rel="Chapter" title="9 Additional HTTP Requirements/Considerations" href="#rfc.section.9">
      <link rel="Chapter" title="10 Security Considerations" href="#rfc.section.10">
      <link rel="Chapter" title="11 Privacy Considerations" href="#rfc.section.11">
      <link rel="Chapter" title="12 IANA Considerations" href="#rfc.section.12">
      <link rel="Chapter" title="13 Acknowledgements" href="#rfc.section.13">
      <link rel="Chapter" href="#rfc.section.14" title="14 References">
      <link rel="Appendix" title="A Change Log (to be removed by RFC Editor before publication)" href="#rfc.section.A">
      <meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.603, 2013/09/18 20:22:25, XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/">
      <meta name="keywords" content="HTTP, SPDY, Web">
      <link rel="schema.dct" href="http://purl.org/dc/terms/">
      <meta name="dct.creator" content="Belshe, M.">
      <meta name="dct.creator" content="Peon, R.">
      <meta name="dct.creator" content="Thomson, M.">
      <meta name="dct.creator" content="Melnikov, A.">
      <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-httpbis-http2-latest">
      <meta name="dct.issued" scheme="ISO8601" content="2013-10-15">
      <meta name="dct.abstract" content="This specification describes an optimized expression of the syntax of the Hypertext Transfer Protocol (HTTP). HTTP/2.0 enables a more efficient use of network resources and a reduced perception of latency by introducing header compression and allowing multiple concurrent messages on the same connection. It also introduces unsolicited push of representations from servers to clients. This document is an alternative to, but does not obsolete, the HTTP/1.1 message syntax. HTTP's existing semantics remain unchanged.">
      <meta name="description" content="This specification describes an optimized expression of the syntax of the Hypertext Transfer Protocol (HTTP). HTTP/2.0 enables a more efficient use of network resources and a reduced perception of latency by introducing header compression and allowing multiple concurrent messages on the same connection. It also introduces unsolicited push of representations from servers to clients. This document is an alternative to, but does not obsolete, the HTTP/1.1 message syntax. HTTP's existing semantics remain unchanged.">
   </head>
   <body onload="init();">
      <table class="header">
         <tbody>
            <tr>
               <td class="left">HTTPbis Working Group</td>
               <td class="right">M. Belshe</td>
            </tr>
            <tr>
               <td class="left">Internet-Draft</td>
               <td class="right">Twist</td>
            </tr>
            <tr>
               <td class="left">Intended status: Standards Track</td>
               <td class="right">R. Peon</td>
            </tr>
            <tr>
               <td class="left">Expires: April 18, 2014</td>
               <td class="right">Google, Inc</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">M. Thomson, Editor</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">Microsoft</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">A. Melnikov, Editor</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">Isode Ltd</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">October 15, 2013</td>
            </tr>
         </tbody>
      </table>
      <p class="title">Hypertext Transfer Protocol version 2.0<br><span class="filename">draft-ietf-httpbis-http2-latest</span></p>
      <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
      <p>This specification describes an optimized expression of the syntax of the Hypertext Transfer Protocol (HTTP). HTTP/2.0 enables
         a more efficient use of network resources and a reduced perception of latency by introducing header compression and allowing
         multiple concurrent messages on the same connection. It also introduces unsolicited push of representations from servers to
         clients.
      </p>
      <p>This document is an alternative to, but does not obsolete, the HTTP/1.1 message syntax. HTTP's existing semantics remain unchanged.</p>
      <h1 id="rfc.note.1"><a href="#rfc.note.1">Editorial Note (To be removed by RFC Editor)</a></h1>
      <p>Discussion of this draft takes place on the HTTPBIS working group mailing list (ietf-http-wg@w3.org), which is archived at &lt;<a href="http://lists.w3.org/Archives/Public/ietf-http-wg/">http://lists.w3.org/Archives/Public/ietf-http-wg/</a>&gt;.
      </p>
      <p>Working Group information and related documents can be found at &lt;<a href="http://tools.ietf.org/wg/httpbis/">http://tools.ietf.org/wg/httpbis/</a>&gt; (Wiki) and &lt;<a href="https://github.com/http2/http2-spec">https://github.com/http2/http2-spec</a>&gt; (source code and issues tracker).
      </p>
      <p>The changes in this draft are summarized in <a href="#changes.since.draft-ietf-httpbis-http2-06" title="Since draft-ietf-httpbis-http2-06">Appendix&nbsp;A.1</a>.
      </p>
      <div id="rfc.status">
         <h1><a href="#rfc.status">Status of This Memo</a></h1>
         <p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
         <p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute
            working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.
         </p>
         <p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other
            documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work
            in progress”.
         </p>
         <p>This Internet-Draft will expire on April 18, 2014.</p>
      </div>
      <div id="rfc.copyrightnotice">
         <h1><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
         <p>Copyright © 2013 IETF Trust and the persons identified as the document authors. All rights reserved.</p>
         <p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights
            and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License
            text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified
            BSD License.
         </p>
      </div>
      <hr class="noprint">
      <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
      <ul class="toc">
         <li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#intro">Introduction</a><ul>
               <li><a href="#rfc.section.1.1">1.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.1">Document Organization</a></li>
               <li><a href="#rfc.section.1.2">1.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.2">Conventions and Terminology</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#Overview">HTTP/2.0 Protocol Overview</a><ul>
               <li><a href="#rfc.section.2.1">2.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.1">HTTP Frames</a></li>
               <li><a href="#rfc.section.2.2">2.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.2">HTTP Multiplexing</a></li>
               <li><a href="#rfc.section.2.3">2.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.3">HTTP Semantics</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#starting">Starting HTTP/2.0</a><ul>
               <li><a href="#rfc.section.3.1">3.1</a>&nbsp;&nbsp;&nbsp;<a href="#versioning">HTTP/2.0 Version Identification</a></li>
               <li><a href="#rfc.section.3.2">3.2</a>&nbsp;&nbsp;&nbsp;<a href="#discover-http">Starting HTTP/2.0 for "http" URIs</a><ul>
                     <li><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#Http2SettingsHeader">HTTP2-Settings Header</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.3.3">3.3</a>&nbsp;&nbsp;&nbsp;<a href="#discover-https">Starting HTTP/2.0 for "https" URIs</a></li>
               <li><a href="#rfc.section.3.4">3.4</a>&nbsp;&nbsp;&nbsp;<a href="#known-http">Starting HTTP/2.0 with Prior Knowledge</a></li>
               <li><a href="#rfc.section.3.5">3.5</a>&nbsp;&nbsp;&nbsp;<a href="#ConnectionHeader">HTTP/2.0 Connection Header</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#FramingLayer">HTTP Frames</a><ul>
               <li><a href="#rfc.section.4.1">4.1</a>&nbsp;&nbsp;&nbsp;<a href="#FrameHeader">Frame Format</a></li>
               <li><a href="#rfc.section.4.2">4.2</a>&nbsp;&nbsp;&nbsp;<a href="#FrameSize">Frame Size</a></li>
               <li><a href="#rfc.section.4.3">4.3</a>&nbsp;&nbsp;&nbsp;<a href="#HeaderBlock">Header Compression and Decompression</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#StreamsLayer">Streams and Multiplexing</a><ul>
               <li><a href="#rfc.section.5.1">5.1</a>&nbsp;&nbsp;&nbsp;<a href="#StreamStates">Stream States</a><ul>
                     <li><a href="#rfc.section.5.1.1">5.1.1</a>&nbsp;&nbsp;&nbsp;<a href="#StreamIdentifiers">Stream Identifiers</a></li>
                     <li><a href="#rfc.section.5.1.2">5.1.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.1.2">Stream Concurrency</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.5.2">5.2</a>&nbsp;&nbsp;&nbsp;<a href="#FlowControl">Flow Control</a><ul>
                     <li><a href="#rfc.section.5.2.1">5.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#fc-principles">Flow Control Principles</a></li>
                     <li><a href="#rfc.section.5.2.2">5.2.2</a>&nbsp;&nbsp;&nbsp;<a href="#DisableFlowControl">Appropriate Use of Flow Control</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.5.3">5.3</a>&nbsp;&nbsp;&nbsp;<a href="#StreamPriority">Stream priority</a></li>
               <li><a href="#rfc.section.5.4">5.4</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.4">Error Handling</a><ul>
                     <li><a href="#rfc.section.5.4.1">5.4.1</a>&nbsp;&nbsp;&nbsp;<a href="#ConnectionErrorHandler">Connection Error Handling</a></li>
                     <li><a href="#rfc.section.5.4.2">5.4.2</a>&nbsp;&nbsp;&nbsp;<a href="#StreamErrorHandler">Stream Error Handling</a></li>
                     <li><a href="#rfc.section.5.4.3">5.4.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.4.3">Connection Termination</a></li>
                  </ul>
               </li>
            </ul>
         </li>
         <li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#frame-types">Frame Definitions</a><ul>
               <li><a href="#rfc.section.6.1">6.1</a>&nbsp;&nbsp;&nbsp;<a href="#DATA">DATA</a></li>
               <li><a href="#rfc.section.6.2">6.2</a>&nbsp;&nbsp;&nbsp;<a href="#HEADERS">HEADERS</a></li>
               <li><a href="#rfc.section.6.3">6.3</a>&nbsp;&nbsp;&nbsp;<a href="#PRIORITY">PRIORITY</a></li>
               <li><a href="#rfc.section.6.4">6.4</a>&nbsp;&nbsp;&nbsp;<a href="#RST_STREAM">RST_STREAM</a></li>
               <li><a href="#rfc.section.6.5">6.5</a>&nbsp;&nbsp;&nbsp;<a href="#SETTINGS">SETTINGS</a><ul>
                     <li><a href="#rfc.section.6.5.1">6.5.1</a>&nbsp;&nbsp;&nbsp;<a href="#SettingFormat">Setting Format</a></li>
                     <li><a href="#rfc.section.6.5.2">6.5.2</a>&nbsp;&nbsp;&nbsp;<a href="#SettingValues">Defined Settings</a></li>
                     <li><a href="#rfc.section.6.5.3">6.5.3</a>&nbsp;&nbsp;&nbsp;<a href="#SettingsSync">Settings Synchronization</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.6.6">6.6</a>&nbsp;&nbsp;&nbsp;<a href="#PUSH_PROMISE">PUSH_PROMISE</a></li>
               <li><a href="#rfc.section.6.7">6.7</a>&nbsp;&nbsp;&nbsp;<a href="#PING">PING</a></li>
               <li><a href="#rfc.section.6.8">6.8</a>&nbsp;&nbsp;&nbsp;<a href="#GOAWAY">GOAWAY</a></li>
               <li><a href="#rfc.section.6.9">6.9</a>&nbsp;&nbsp;&nbsp;<a href="#WINDOW_UPDATE">WINDOW_UPDATE</a><ul>
                     <li><a href="#rfc.section.6.9.1">6.9.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.9.1">The Flow Control Window</a></li>
                     <li><a href="#rfc.section.6.9.2">6.9.2</a>&nbsp;&nbsp;&nbsp;<a href="#InitialWindowSize">Initial Flow Control Window Size</a></li>
                     <li><a href="#rfc.section.6.9.3">6.9.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.9.3">Reducing the Stream Window Size</a></li>
                     <li><a href="#rfc.section.6.9.4">6.9.4</a>&nbsp;&nbsp;&nbsp;<a href="#EndFlowControl">Ending Flow Control</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.6.10">6.10</a>&nbsp;&nbsp;&nbsp;<a href="#CONTINUATION">CONTINUATION</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#ErrorCodes">Error Codes</a></li>
         <li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#HTTPLayer">HTTP Message Exchanges</a><ul>
               <li><a href="#rfc.section.8.1">8.1</a>&nbsp;&nbsp;&nbsp;<a href="#HttpSequence">HTTP Request/Response Exchange</a><ul>
                     <li><a href="#rfc.section.8.1.1">8.1.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.1.1">Examples</a></li>
                     <li><a href="#rfc.section.8.1.2">8.1.2</a>&nbsp;&nbsp;&nbsp;<a href="#HttpHeaders">HTTP Header Fields</a><ul>
                           <li><a href="#rfc.section.8.1.2.1">8.1.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#HttpRequest">Request Header Fields</a></li>
                           <li><a href="#rfc.section.8.1.2.2">8.1.2.2</a>&nbsp;&nbsp;&nbsp;<a href="#HttpResponse">Response Header Fields</a></li>
                        </ul>
                     </li>
                     <li><a href="#rfc.section.8.1.3">8.1.3</a>&nbsp;&nbsp;&nbsp;<a href="#Reliability">Request Reliability Mechanisms in HTTP/2.0</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.8.2">8.2</a>&nbsp;&nbsp;&nbsp;<a href="#PushResources">Server Push</a><ul>
                     <li><a href="#rfc.section.8.2.1">8.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.2.1">Push Requests</a></li>
                     <li><a href="#rfc.section.8.2.2">8.2.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.2.2">Push Responses</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.8.3">8.3</a>&nbsp;&nbsp;&nbsp;<a href="#CONNECT">The CONNECT Method</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.9">9.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpExtra">Additional HTTP Requirements/Considerations</a><ul>
               <li><a href="#rfc.section.9.1">9.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.9.1">Connection Management</a></li>
               <li><a href="#rfc.section.9.2">9.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.9.2">Use of TLS Features</a></li>
               <li><a href="#rfc.section.9.3">9.3</a>&nbsp;&nbsp;&nbsp;<a href="#Compression">GZip Content-Encoding</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.10">10.</a>&nbsp;&nbsp;&nbsp;<a href="#security">Security Considerations</a><ul>
               <li><a href="#rfc.section.10.1">10.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.1">Server Authority and Same-Origin</a></li>
               <li><a href="#rfc.section.10.2">10.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.2">Cross-Protocol Attacks</a></li>
               <li><a href="#rfc.section.10.3">10.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.3">Intermediary Encapsulation Attacks</a></li>
               <li><a href="#rfc.section.10.4">10.4</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.4">Cacheability of Pushed Resources</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.11">11.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.11">Privacy Considerations</a></li>
         <li><a href="#rfc.section.12">12.</a>&nbsp;&nbsp;&nbsp;<a href="#iana">IANA Considerations</a><ul>
               <li><a href="#rfc.section.12.1">12.1</a>&nbsp;&nbsp;&nbsp;<a href="#iana-alpn">Registration of HTTP/2.0 Identification String</a></li>
               <li><a href="#rfc.section.12.2">12.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.12.2">Frame Type Registry</a></li>
               <li><a href="#rfc.section.12.3">12.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.12.3">Error Code Registry</a></li>
               <li><a href="#rfc.section.12.4">12.4</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.12.4">Settings Registry</a></li>
               <li><a href="#rfc.section.12.5">12.5</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.12.5">HTTP2-Settings Header Field Registration</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.13">13.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.13">Acknowledgements</a></li>
         <li><a href="#rfc.section.14">14.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul>
               <li><a href="#rfc.section.14.1">14.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li>
               <li><a href="#rfc.section.14.2">14.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li>
            </ul>
         </li>
         <li><a href="#rfc.authors">Authors' Addresses</a></li>
         <li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#change.log">Change Log (to be removed by RFC Editor before publication)</a><ul>
               <li><a href="#rfc.section.A.1">A.1</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-06">Since draft-ietf-httpbis-http2-06</a></li>
               <li><a href="#rfc.section.A.2">A.2</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-05">Since draft-ietf-httpbis-http2-05</a></li>
               <li><a href="#rfc.section.A.3">A.3</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-04">Since draft-ietf-httpbis-http2-04</a></li>
               <li><a href="#rfc.section.A.4">A.4</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-03">Since draft-ietf-httpbis-http2-03</a></li>
               <li><a href="#rfc.section.A.5">A.5</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-02">Since draft-ietf-httpbis-http2-02</a></li>
               <li><a href="#rfc.section.A.6">A.6</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-01">Since draft-ietf-httpbis-http2-01</a></li>
               <li><a href="#rfc.section.A.7">A.7</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-00">Since draft-ietf-httpbis-http2-00</a></li>
               <li><a href="#rfc.section.A.8">A.8</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-mbelshe-httpbis-spdy-00">Since draft-mbelshe-httpbis-spdy-00</a></li>
            </ul>
         </li>
      </ul>
      <ul class="toc">
         <li>Figures
            
            <ul>
               <li><a href="#rfc.figure.1">Figure 1: Frame Header</a></li>
               <li><a href="#rfc.figure.2">Figure 2: Stream States</a></li>
               <li><a href="#rfc.figure.3">Figure 3: HEADERS Frame Payload</a></li>
               <li><a href="#rfc.figure.4">Figure 4: PRIORITY Frame Payload</a></li>
               <li><a href="#rfc.figure.5">Figure 5: RST_STREAM Frame Payload</a></li>
               <li><a href="#rfc.figure.6">Figure 6: Setting Format</a></li>
               <li><a href="#rfc.figure.7">Figure 7: PUSH_PROMISE Payload Format</a></li>
               <li><a href="#rfc.figure.8">Figure 8: PING Payload Format</a></li>
               <li><a href="#rfc.figure.9">Figure 9: GOAWAY Payload Format</a></li>
               <li><a href="#rfc.figure.10">Figure 10: WINDOW_UPDATE Payload Format</a></li>
               <li><a href="#rfc.figure.11">Figure 11: CONTINUATION Frame Payload</a></li>
            </ul>
         </li>
      </ul>
      <div id="intro">
         <h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#intro">Introduction</a></h1>
         <p id="rfc.section.1.p.1">The Hypertext Transfer Protocol (HTTP) is a wildly successful protocol. However, the HTTP/1.1 message format (<a href="#HTTP-p1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p1-messaging.html#http.message" title="Message Format">Section 3</a>) is optimized for implementation simplicity and accessibility, not application performance. As such it has several characteristics
            that have a negative overall effect on application performance.
         </p>
         <p id="rfc.section.1.p.2">In particular, HTTP/1.0 only allows one request to be outstanding at a time on a given connection. HTTP/1.1 pipelining only
            partially addressed request concurrency and suffers from head-of-line blocking. Therefore, clients that need to make many
            requests typically use multiple connections to a server in order to reduce latency.
         </p>
         <p id="rfc.section.1.p.3">Furthermore, HTTP/1.1 header fields are often repetitive and verbose, which, in addition to generating more or larger network
            packets, can cause the small initial TCP congestion window to quickly fill. This can result in excessive latency when multiple
            requests are made on a single new TCP connection.
         </p>
         <p id="rfc.section.1.p.4">This document addresses these issues by defining an optimized mapping of HTTP's semantics to an underlying connection. Specifically,
            it allows interleaving of request and response messages on the same connection and uses an efficient coding for HTTP header
            fields. It also allows prioritization of requests, letting more important requests complete more quickly, further improving
            performance.
         </p>
         <p id="rfc.section.1.p.5">The resulting protocol is designed to be more friendly to the network, because fewer TCP connections can be used, in comparison
            to HTTP/1.x. This means less competition with other flows, and longer-lived connections, which in turn leads to better utilization
            of available network capacity.
         </p>
         <p id="rfc.section.1.p.6">Finally, this encapsulation also enables more scalable processing of messages through use of binary message framing.</p>
         <div>
            <h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;Document Organization
            </h2>
            <p id="rfc.section.1.1.p.1">The HTTP/2.0 Specification is split into three parts: starting HTTP/2.0 (<a href="#starting" title="Starting HTTP/2.0">Section&nbsp;3</a>), which covers how a HTTP/2.0 connection is initiated; a framing layer (<a href="#FramingLayer" title="HTTP Frames">Section&nbsp;4</a>), which multiplexes a single TCP connection into independent frames of various types; and an HTTP layer (<a href="#HTTPLayer" title="HTTP Message Exchanges">Section&nbsp;8</a>), which specifies the mechanism for expressing HTTP interactions using the framing layer. While some of the framing layer
               concepts are isolated from HTTP, building a generic framing layer has not been a goal. The framing layer is tailored to the
               needs of the HTTP protocol and server push.
            </p>
         </div>
         <div>
            <h2 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2</a>&nbsp;Conventions and Terminology
            </h2>
            <p id="rfc.section.1.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
               in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite>.
            </p>
            <p id="rfc.section.1.2.p.2">All numeric values are in network byte order. Values are unsigned unless otherwise indicated. Literal values are provided
               in decimal or hexadecimal as appropriate. Hexadecimal literals are prefixed with <samp>0x</samp> to distinguish them from decimal literals.
            </p>
            <p id="rfc.section.1.2.p.3">The following terms are used: </p>
            <dl>
               <dt>client:</dt>
               <dd>The endpoint initiating the HTTP connection.</dd>
               <dt>connection:</dt>
               <dd>A transport-level connection between two endpoints.</dd>
               <dt>connection error:</dt>
               <dd>An error on the HTTP/2.0 connection.</dd>
               <dt>endpoint:</dt>
               <dd>Either the client or server of the connection.</dd>
               <dt>frame:</dt>
               <dd>The smallest unit of communication within an HTTP/2.0 connection, consisting of a header and a variable-length sequence of
                  bytes structured according to the frame type.
               </dd>
               <dt>peer:</dt>
               <dd>An endpoint. When discussing a particular endpoint, "peer" refers to the endpoint that is remote to the primary subject of
                  discussion.
               </dd>
               <dt>receiver:</dt>
               <dd>An endpoint that is receiving frames.</dd>
               <dt>sender:</dt>
               <dd>An endpoint that is transmitting frames.</dd>
               <dt>server:</dt>
               <dd>The endpoint which did not initiate the HTTP connection.</dd>
               <dt>stream:</dt>
               <dd>A bi-directional flow of frames across a virtual channel within the HTTP/2.0 connection.</dd>
               <dt>stream error:</dt>
               <dd>An error on the individual HTTP/2.0 stream.</dd>
            </dl>
         </div>
      </div>
      <div id="Overview">
         <h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#Overview">HTTP/2.0 Protocol Overview</a></h1>
         <p id="rfc.section.2.p.1">HTTP/2.0 provides an optimized transport for HTTP semantics.</p>
         <p id="rfc.section.2.p.2">An HTTP/2.0 connection is an application level protocol running on top of a TCP connection (<a href="#TCP"><cite title="Transmission Control Protocol">[TCP]</cite></a>). The client is the TCP connection initiator.
         </p>
         <p id="rfc.section.2.p.3">This document describes the HTTP/2.0 protocol using a logical structure that is formed of three parts: framing, streams, and
            application mapping. This structure is provided primarily as an aid to specification, implementations are free to diverge
            from this structure as necessary.
         </p>
         <div>
            <h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;HTTP Frames
            </h2>
            <p id="rfc.section.2.1.p.1">HTTP/2.0 provides an efficient serialization of HTTP semantics. HTTP requests and responses are encoded into length-prefixed
               frames (see <a href="#FrameHeader" title="Frame Format">Section&nbsp;4.1</a>).
            </p>
            <p id="rfc.section.2.1.p.2">HTTP headers are compressed into a series of frames that contain header block fragments (see <a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>).
            </p>
         </div>
         <div>
            <h2 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;HTTP Multiplexing
            </h2>
            <p id="rfc.section.2.2.p.1">HTTP/2.0 provides the ability to multiplex HTTP requests and responses over a single connection. Multiple requests or responses
               can be sent concurrently on a connection using streams (<a href="#StreamsLayer" title="Streams and Multiplexing">Section&nbsp;5</a>). In order to maintain independent streams, flow control and prioritization are necessary.
            </p>
         </div>
         <div>
            <h2 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3</a>&nbsp;HTTP Semantics
            </h2>
            <p id="rfc.section.2.3.p.1">HTTP/2.0 defines how HTTP requests and responses are mapped to streams (see <a href="#HttpSequence" title="HTTP Request/Response Exchange">Section&nbsp;8.1</a>) and introduces a new interaction model, server push (<a href="#PushResources" title="Server Push">Section&nbsp;8.2</a>).
            </p>
         </div>
      </div>
      <div id="starting">
         <h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#starting">Starting HTTP/2.0</a></h1>
         <p id="rfc.section.3.p.1">HTTP/2.0 uses the same "http" and "https" URI schemes used by HTTP/1.1. HTTP/2.0 shares the same default port numbers: 80
            for "http" URIs and 443 for "https" URIs. As a result, implementations processing requests for target resource URIs like <samp>http://example.org/foo</samp> or <samp>https://example.com/bar</samp> are required to first discover whether the upstream server (the immediate peer to which the client wishes to establish a connection)
            supports HTTP/2.0.
         </p>
         <p id="rfc.section.3.p.2">The means by which support for HTTP/2.0 is determined is different for "http" and "https" URIs. Discovery for "http" URIs
            is described in <a href="#discover-http" title="Starting HTTP/2.0 for &#34;http&#34; URIs">Section&nbsp;3.2</a>. Discovery for "https" URIs is described in <a href="#discover-https" title="Starting HTTP/2.0 for &#34;https&#34; URIs">Section&nbsp;3.3</a>.
         </p>
         <div id="versioning">
            <h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;<a href="#versioning">HTTP/2.0 Version Identification</a></h2>
            <p id="rfc.section.3.1.p.1">The protocol defined in this document is identified using the string "HTTP/2.0". This identification is used in the HTTP/1.1
               Upgrade header field, in the <a href="#TLSALPN">TLS application layer protocol negotiation extension</a> <cite title="Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension">[TLSALPN]</cite> field, and other places where protocol identification is required.
            </p>
            <p id="rfc.section.3.1.p.2">Negotiating "HTTP/2.0" implies the use of the transport, security, framing and message semantics described in this document.</p>
            <p id="rfc.section.3.1.p.3"><span class="comment" id="rfc.comment.1">[<a href="#rfc.comment.1" class="smpl">rfc.comment.1</a>: Editor's Note: please remove the remainder of this section prior to the publication of a final version of this document.]</span> 
            </p>
            <p id="rfc.section.3.1.p.4">Only implementations of the final, published RFC can identify themselves as "HTTP/2.0". Until such an RFC exists, implementations
               MUST NOT identify themselves using "HTTP/2.0".
            </p>
            <p id="rfc.section.3.1.p.5">Examples and text throughout the rest of this document use "HTTP/2.0" as a matter of editorial convenience only. Implementations
               of draft versions MUST NOT identify using this string. The exception to this rule is the string included in the connection
               header sent by clients immediately after establishing an HTTP/2.0 connection (see <a href="#ConnectionHeader" title="HTTP/2.0 Connection Header">Section&nbsp;3.5</a>); this fixed length sequence of octets does not change.
            </p>
            <p id="rfc.section.3.1.p.6">Implementations of draft versions of the protocol MUST add the string "-draft-" and the corresponding draft number to the
               identifier before the separator ('/'). For example, draft-ietf-httpbis-http2-03 is identified using the string "HTTP-draft-03/2.0".
            </p>
            <p id="rfc.section.3.1.p.7">Non-compatible experiments that are based on these draft versions MUST instead replace the string "draft" with a different
               identifier. For example, an experimental implementation of packet mood-based encoding based on draft-ietf-httpbis-http2-07
               might identify itself as "HTTP-emo-07/2.0". Note that any label MUST conform to the "token" syntax defined in <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p1-messaging.html#field.components" title="Field value components">Section 3.2.6</a> of <a href="#HTTP-p1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>. Experimenters are encouraged to coordinate their experiments on the ietf-http-wg@w3.org mailing list.
            </p>
         </div>
         <div id="discover-http">
            <h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a href="#discover-http">Starting HTTP/2.0 for "http" URIs</a></h2>
            <p id="rfc.section.3.2.p.1">A client that makes a request to an "http" URI without prior knowledge about support for HTTP/2.0 uses the HTTP Upgrade mechanism
               (<a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p1-messaging.html#header.upgrade" title="Upgrade">Section 6.7</a> of <a href="#HTTP-p1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>). The client makes an HTTP/1.1 request that includes an Upgrade header field identifying HTTP/2.0. The HTTP/1.1 request MUST
               include exactly one HTTP2-Settings (<a href="#Http2SettingsHeader" title="HTTP2-Settings Header">Section&nbsp;3.2.1</a>) header.
            </p>
            <div id="rfc.figure.u.1"></div>
            <p>For example:</p><pre class="text2">GET /default.htm HTTP/1.1
Host: server.example.com
Connection: Upgrade, HTTP2-Settings
Upgrade: HTTP/2.0
HTTP2-Settings: &lt;base64url encoding of HTTP/2.0 SETTINGS payload&gt;
</pre><p id="rfc.section.3.2.p.3">Requests that contain an entity body MUST be sent in their entirety before the client can send HTTP/2.0 frames. This means
               that a large request entity can block the use of the connection until it is completely sent.
            </p>
            <p id="rfc.section.3.2.p.4">If concurrency of an initial request with subsequent requests is important, a small request can be used to perform the upgrade
               to HTTP/2.0, at the cost of an additional round trip.
            </p>
            <p id="rfc.section.3.2.p.5">A server that does not support HTTP/2.0 can respond to the request as though the Upgrade header field were absent:</p>
            <div id="rfc.figure.u.2"></div><pre class="text">HTTP/1.1 200 OK
Content-Length: 243
Content-Type: text/html

...
</pre><p id="rfc.section.3.2.p.7">A server that supports HTTP/2.0 can accept the upgrade with a 101 (Switching Protocols) response. After the empty line that
               terminates the 101 response, the server can begin sending HTTP/2.0 frames. These frames MUST include a response to the request
               that initiated the Upgrade.
            </p>
            <div id="rfc.figure.u.3"></div><pre class="text">HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: HTTP/2.0

[ HTTP/2.0 connection ...
</pre><p id="rfc.section.3.2.p.9">The first HTTP/2.0 frame sent by the server is a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;6.5</a>). Upon receiving the 101 response, the client sends a connection header (<a href="#ConnectionHeader" title="HTTP/2.0 Connection Header">Section&nbsp;3.5</a>), which includes a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame.
            </p>
            <p id="rfc.section.3.2.p.10">The HTTP/1.1 request that is sent prior to upgrade is assigned stream identifier 1 and is assigned the highest possible priority.
               Stream 1 is implicitly half closed from the client toward the server, since the request is completed as an HTTP/1.1 request.
               After commencing the HTTP/2.0 connection, stream 1 is used for the response.
            </p>
            <div id="Http2SettingsHeader">
               <h3 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;<a href="#Http2SettingsHeader">HTTP2-Settings Header</a></h3>
               <p id="rfc.section.3.2.1.p.1">A request that upgrades from HTTP/1.1 to HTTP/2.0 MUST include exactly one <samp>HTTP2-Settings</samp> header field. The <samp>HTTP2-Settings</samp> header field is a hop-by-hop header field that includes settings that govern the HTTP/2.0 connection, provided in anticipation
                  of the server accepting the request to upgrade. A server MUST reject an attempt to upgrade if this header is not present.
               </p>
               <div id="rfc.figure.u.4"></div><pre class="inline">HTTP2-Settings    = token68
</pre><p id="rfc.section.3.2.1.p.3">The content of the <samp>HTTP2-Settings</samp> header field is the payload of a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;6.5</a>), encoded as a base64url string (that is, the URL- and filename-safe Base64 encoding described in <a href="http://tools.ietf.org/html/rfc4648#section-5">Section 5</a> of <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, with any trailing '=' characters omitted). The <a href="#RFC5234">ABNF</a> <cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite> production for <samp>token68</samp> is defined in <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p7-auth.html#challenge.and.response" title="Challenge and Response">Section 2.1</a> of <a href="#HTTP-p7"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[HTTP-p7]</cite></a>.
               </p>
               <p id="rfc.section.3.2.1.p.4">The client MUST include values for the following settings (<a href="#SettingFormat" title="Setting Format">Section&nbsp;6.5.1</a>): 
               </p>
               <ul>
                  <li>SETTINGS_MAX_CONCURRENT_STREAMS</li>
                  <li>SETTINGS_INITIAL_WINDOW_SIZE</li>
               </ul>
               <p id="rfc.section.3.2.1.p.5">As a hop-by-hop header field, the <samp>Connection</samp> header field MUST include a value of <samp>HTTP2-Settings</samp> in addition to <samp>Upgrade</samp> when upgrading to HTTP/2.0.
               </p>
               <p id="rfc.section.3.2.1.p.6">A server decodes and interprets these values as it would any other <a href="#SETTINGS" class="smpl">SETTINGS</a> frame. Providing these values in the Upgrade request ensures that the protocol does not require default values for the above
                  settings, and gives a client an opportunity to provide other settings prior to receiving any frames from the server.
               </p>
            </div>
         </div>
         <div id="discover-https">
            <h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;<a href="#discover-https">Starting HTTP/2.0 for "https" URIs</a></h2>
            <p id="rfc.section.3.3.p.1">A client that makes a request to an "https" URI without prior knowledge about support for HTTP/2.0 uses <a href="#TLS12">TLS</a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[TLS12]</cite> with the <a href="#TLSALPN">application layer protocol negotiation extension</a> <cite title="Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension">[TLSALPN]</cite>.
            </p>
            <p id="rfc.section.3.3.p.2">Once TLS negotiation is complete, both the client and the server send a connection header (<a href="#ConnectionHeader" title="HTTP/2.0 Connection Header">Section&nbsp;3.5</a>).
            </p>
         </div>
         <div id="known-http">
            <h2 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4</a>&nbsp;<a href="#known-http">Starting HTTP/2.0 with Prior Knowledge</a></h2>
            <p id="rfc.section.3.4.p.1">A client can learn that a particular server supports HTTP/2.0 by other means. A client MAY immediately send HTTP/2.0 frames
               to a server that is known to support HTTP/2.0, after the connection header (<a href="#ConnectionHeader" title="HTTP/2.0 Connection Header">Section&nbsp;3.5</a>). This only affects the resolution of "http" URIs; servers supporting HTTP/2.0 are required to support <a href="#TLSALPN">protocol negotiation in TLS</a> <cite title="Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension">[TLSALPN]</cite> for "https" URIs.
            </p>
            <p id="rfc.section.3.4.p.2">Prior support for HTTP/2.0 is not a strong signal that a given server will support HTTP/2.0 for future connections. It is
               possible for server configurations to change or for configurations to differ between instances in clustered server. Interception
               proxies (a.k.a. "transparent" proxies) are another source of variability.
            </p>
         </div>
         <div id="ConnectionHeader">
            <h2 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5</a>&nbsp;<a href="#ConnectionHeader">HTTP/2.0 Connection Header</a></h2>
            <p id="rfc.section.3.5.p.1">Upon establishment of a TCP connection and determination that HTTP/2.0 will be used by both peers, each endpoint MUST send
               a connection header as a final confirmation and to establish the initial settings for the HTTP/2.0 connection.
            </p>
            <p id="rfc.section.3.5.p.2">The client connection header is a sequence of 24 octets, which in hex notation are:</p>
            <div id="rfc.figure.u.5"></div><pre class="inline">505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
</pre><p id="rfc.section.3.5.p.4">(the string <samp>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</samp>) followed by a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;6.5</a>). The client sends the client connection header immediately upon receipt of a 101 Switching Protocols response (indicating
               a successful upgrade), or as the first application data octets of a TLS connection. If starting an HTTP/2.0 connection with
               prior knowledge of server support for the protocol, the client connection header is sent upon connection establishment.
            </p>
            <p id="rfc.section.3.5.p.5"></p>
            <ul class="empty">
               <li>The client connection header is selected so that a large proportion of HTTP/1.1 or HTTP/1.0 servers and intermediaries do
                  not attempt to process further frames. Note that this does not address the concerns raised in <a href="#TALKING"><cite title="Talking to Yourself for Fun and Profit">[TALKING]</cite></a>.
               </li>
            </ul>
            <p id="rfc.section.3.5.p.6">The server connection header consists of just a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;6.5</a>) that MUST be the first frame the server sends in the HTTP/2.0 connection.
            </p>
            <p id="rfc.section.3.5.p.7">To avoid unnecessary latency, clients are permitted to send additional frames to the server immediately after sending the
               client connection header, without waiting to receive the server connection header. It is important to note, however, that
               the server connection header <a href="#SETTINGS" class="smpl">SETTINGS</a> frame might include parameters that necessarily alter how a client is expected to communicate with the server. Upon receiving
               the <a href="#SETTINGS" class="smpl">SETTINGS</a> frame, the client is expected to honor any parameters established.
            </p>
            <p id="rfc.section.3.5.p.8">Clients and servers MUST terminate the TCP connection if either peer does not begin with a valid connection header. A <a href="#GOAWAY" class="smpl">GOAWAY</a> frame (<a href="#GOAWAY" title="GOAWAY">Section&nbsp;6.8</a>) MAY be omitted if it is clear that the peer is not using HTTP/2.0.
            </p>
         </div>
      </div>
      <div id="FramingLayer">
         <h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#FramingLayer">HTTP Frames</a></h1>
         <p id="rfc.section.4.p.1">Once the HTTP/2.0 connection is established, endpoints can begin exchanging frames.</p>
         <div id="FrameHeader">
            <h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a>&nbsp;<a href="#FrameHeader">Frame Format</a></h2>
            <p id="rfc.section.4.1.p.1">All frames begin with an 8-octet header followed by a payload of between 0 and 65,535 octets.</p>
            <div id="rfc.figure.1"></div><pre class="inline">  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | R |     Length (16)           |   Type (8)    |   Flags (8)   |
 +-+-+-----------+---------------+-------------------------------+
 |R|                 Stream Identifier (31)                      |
 +-+-------------------------------------------------------------+
 |                   Frame Payload (0...)                      ...
 +---------------------------------------------------------------+
          </pre><p class="figure">Figure 1: Frame Header</p>
            <p id="rfc.section.4.1.p.3">The fields of the frame header are defined as: </p>
            <dl>
               <dt>R:</dt>
               <dd>
                  <p>A reserved 2-bit field. The semantics of this bit are undefined and the bit MUST remain unset (0) when sending and MUST be
                     ignored when receiving.
                  </p>
               </dd>
               <dt>Length:</dt>
               <dd>
                  <p>The length of the frame payload expressed as an unsigned 14-bit integer. The 8 octets of the frame header are not included
                     in this value.
                  </p>
               </dd>
               <dt>Type:</dt>
               <dd>
                  <p>The 8-bit type of the frame. The frame type determines how the remainder of the frame header and payload are interpreted.
                     Implementations MUST ignore frames of unsupported or unrecognized types.
                  </p>
               </dd>
               <dt>Flags:</dt>
               <dd>
                  <p>An 8-bit field reserved for frame-type specific boolean flags.</p>
                  <p>Flags are assigned semantics specific to the indicated frame type. Flags that have no defined semantics for a particular frame
                     type MUST be ignored, and MUST be left unset (0) when sending.
                  </p>
               </dd>
               <dt>R:</dt>
               <dd>
                  <p>A reserved 1-bit field. The semantics of this bit are undefined and the bit MUST remain unset (0) when sending and MUST be
                     ignored when receiving.
                  </p>
               </dd>
               <dt>Stream Identifier:</dt>
               <dd>
                  <p>A 31-bit stream identifier (see <a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>). The value 0 is reserved for frames that are associated with the connection as a whole as opposed to an individual stream.
                  </p>
               </dd>
            </dl>
            <p id="rfc.section.4.1.p.4">The structure and content of the frame payload is dependent entirely on the frame type.</p>
         </div>
         <div id="FrameSize">
            <h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a>&nbsp;<a href="#FrameSize">Frame Size</a></h2>
            <p id="rfc.section.4.2.p.1">The maximum size of a frame payload varies by frame type. The absolute maximum size of a frame is 2<sup>14</sup>-1 (16,383) octets. All implementations SHOULD be capable of receiving and minimally processing frames up to this maximum
               size.
            </p>
            <p id="rfc.section.4.2.p.2">Certain frame types, such as <a href="#PING" class="smpl">PING</a> (see <a href="#PING" title="PING">Section&nbsp;6.7</a>), impose additional limits on the amount of payload data allowed. Likewise, additional size limits can be set by specific
               application uses (see <a href="#HttpExtra" title="Additional HTTP Requirements/Considerations">Section&nbsp;9</a>).
            </p>
            <p id="rfc.section.4.2.p.3">If a frame size exceeds any defined limit, or is too small to contain mandatory frame data, the endpoint MUST send a <a href="#FRAME_SIZE_ERROR" class="smpl">FRAME_SIZE_ERROR</a> error. Frame size errors in frames that affect connection-level state MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>).
            </p>
         </div>
         <div id="HeaderBlock">
            <h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3</a>&nbsp;<a href="#HeaderBlock">Header Compression and Decompression</a></h2>
            <p id="rfc.section.4.3.p.1">A header in HTTP/2.0 is a name-value pair with one or more associated values. They are used within HTTP request and response
               messages as well as server push operations (see <a href="#PushResources" title="Server Push">Section&nbsp;8.2</a>).
            </p>
            <p id="rfc.section.4.3.p.2">Header sets are logical collections of zero or more header fields arranged at the application layer. When transmitted over
               a connection, the header set is serialized into a header block using <a href="#COMPRESSION">HTTP Header Compression</a> <cite title="HPACK - Header Compression for HTTP/2.0">[COMPRESSION]</cite>. The serialized header block is then divided into one or more octet sequences, called header block fragments, and transmitted
               within the payload of HEADERS (<a href="#HEADERS" title="HEADERS">Section&nbsp;6.2</a>), PUSH_PROMISE (<a href="#PUSH_PROMISE" title="PUSH_PROMISE">Section&nbsp;6.6</a>) or CONTINUATION (<a href="#CONTINUATION" title="CONTINUATION">Section&nbsp;6.10</a>) frames. The receiving endpoint reassembles the header block by concatenating the individual fragments, then decompresses the
               block to reconstruct the header set.
            </p>
            <p id="rfc.section.4.3.p.3">Header block fragments can only be sent as the payload of <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> or <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames.
            </p>
            <p id="rfc.section.4.3.p.4">A compressed and encoded header block is transmitted in a <a href="#HEADERS" class="smpl">HEADERS</a> or <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame, followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames. If the number of octets in the block is greater than the space remaining in the frame, the block is divided into multiple
               fragments, which are then transmitted in multiple frames.
            </p>
            <p id="rfc.section.4.3.p.5">Header blocks MUST be transmitted as a contiguous sequence of frames, with no interleaved frames of any other type, or from
               any other stream. The last frame in a sequence of <a href="#HEADERS" class="smpl">HEADERS</a>/<a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames MUST have the END_HEADERS flag set. The last frame in a sequence of <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a>/<a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames MUST have the END_PUSH_PROMISE/END_HEADERS flag set (respectively).
            </p>
            <p id="rfc.section.4.3.p.6"><a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> and <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames carry data that can modify the compression context maintained by a receiver. An endpoint receiving <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> or <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames MUST reassemble header blocks and perform decompression even if the frames are to be discarded. A receiver MUST terminate
               the connection with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#COMPRESSION_ERROR" class="smpl">COMPRESSION_ERROR</a>, if it does not decompress a header block.
            </p>
         </div>
      </div>
      <div id="StreamsLayer">
         <h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#StreamsLayer">Streams and Multiplexing</a></h1>
         <p id="rfc.section.5.p.1">A "stream" is an independent, bi-directional sequence of <a href="#HEADERS" class="smpl">HEADERS</a> and <a href="#DATA" class="smpl">DATA</a> frames exchanged between the client and server within an HTTP/2.0 connection. Streams have several important characteristics: 
         </p>
         <ul>
            <li>A single HTTP/2.0 connection can contain multiple concurrently open streams, with either endpoint interleaving frames from
               multiple streams.
            </li>
            <li>Streams can be established and used unilaterally or shared by either the client or server.</li>
            <li>Streams can be closed by either endpoint.</li>
            <li>The order in which frames are sent within a stream is significant. Recipients process frames in the order they are received.</li>
            <li>Streams are identified by an integer. Stream identifiers are assigned to streams by the initiating endpoint.</li>
         </ul>
         <div id="StreamStates">
            <h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1</a>&nbsp;<a href="#StreamStates">Stream States</a></h2>
            <p id="rfc.section.5.1.p.1">The lifecycle of a stream is shown in <a href="#StreamStatesFigure">Figure&nbsp;2</a>.
            </p>
            <div id="StreamStatesFigure"></div>
            <div id="rfc.figure.2"></div><pre class="drawing">            
                       +--------+
                 PP    |        |    PP
              ,--------|  idle  |--------.
             /         |        |         \
            v          +--------+          v
     +----------+          |           +----------+
     |          |          | H         |          |
 ,---| reserved |          |           | reserved |---.
 |   | (local)  |          v           | (remote) |   |
 |   +----------+      +--------+      +----------+   |
 |      |          ES  |        |  ES          |      |
 |      | H    ,-------|  open  |-------.      | H    |
 |      |     /        |        |        \     |      |
 |      v    v         +--------+         v    v      |
 |   +----------+          |           +----------+   |
 |   |   half   |          |           |   half   |   |
 |   |  closed  |          | R         |  closed  |   |
 |   | (remote) |          |           | (local)  |   |
 |   +----------+          |           +----------+   |
 |        |                v                 |        |
 |        |  ES / R    +--------+  ES / R    |        |
 |        `-----------&gt;|        |&lt;-----------'        |
 |  R                  | closed |                  R  |
 `--------------------&gt;|        |&lt;--------------------'
                       +--------+

          </pre><p class="figure">Figure 2: Stream States</p>
            <p id="rfc.section.5.1.p.3">Both endpoints have a subjective view of the state of a stream that could be different when frames are in transit. Endpoints
               do not coordinate the creation of streams, they are created unilaterally by either endpoint. The negative consequences of
               a mismatch in states are limited to the "closed" state after sending <a href="#RST_STREAM" class="smpl">RST_STREAM</a>, where frames might be received for some time after closing.
            </p>
            <p id="rfc.section.5.1.p.4">Streams have the following states: </p>
            <dl>
               <dt>idle:</dt>
               <dd>
                  <p><br> All streams start in the "idle" state. In this state, no frames have been exchanged.
                  </p>
                  <p>The following transitions are valid from this state: </p>
                  <ul>
                     <li>Sending or receiving a <a href="#HEADERS" class="smpl">HEADERS</a> frame causes the stream to become "open". The stream identifier is selected as described in <a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>. The same <a href="#HEADERS" class="smpl">HEADERS</a> frame can also cause a stream to immediately become "half closed".
                     </li>
                     <li>Sending a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame marks the associated stream for later use. The stream state for the reserved stream transitions to "reserved (local)".
                     </li>
                     <li>Receiving a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame marks the associated stream as reserved by the remote peer. The state of the stream becomes "reserved (remote)".
                     </li>
                  </ul>
               </dd>
               <dt>reserved (local):</dt>
               <dd>
                  <p><br> A stream in the "reserved (local)" state is one that has been promised by sending a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame. A <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame reserves an idle stream by associating the stream with an open stream that was initiated by the remote peer (see <a href="#PushResources" title="Server Push">Section&nbsp;8.2</a>).
                  </p>
                  <p>In this state, only the following transitions are possible: </p>
                  <ul>
                     <li>The endpoint can send a <a href="#HEADERS" class="smpl">HEADERS</a> frame. This causes the stream to open in a "half closed (remote)" state.
                     </li>
                     <li>Either endpoint can send a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame to cause the stream to become "closed". This releases the stream reservation.
                     </li>
                  </ul>
                  <p> An endpoint MUST NOT send any other type of frame in this state. Receiving any frame other than <a href="#RST_STREAM" class="smpl">RST_STREAM</a> or <a href="#PRIORITY" class="smpl">PRIORITY</a> MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
                  </p>
               </dd>
               <dt>reserved (remote):</dt>
               <dd>
                  <p><br> A stream in the "reserved (remote)" state has been reserved by a remote peer.
                  </p>
                  <p>In this state, only the following transitions are possible: </p>
                  <ul>
                     <li>Receiving a <a href="#HEADERS" class="smpl">HEADERS</a> frame causes the stream to transition to "half closed (local)".
                     </li>
                     <li>Either endpoint can send a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame to cause the stream to become "closed". This releases the stream reservation.
                     </li>
                  </ul>
                  <p> Receiving any other type of frame MUST be treated as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>. An endpoint MAY send <a href="#RST_STREAM" class="smpl">RST_STREAM</a> or <a href="#PRIORITY" class="smpl">PRIORITY</a> frames in this state to cancel or reprioritize the reserved stream.
                  </p>
               </dd>
               <dt>open:</dt>
               <dd>
                  <p><br> A stream in the "open" state may be used by both peers to send frames of any type. In this state, sending peers observe advertised stream level flow control limits (<a href="#FlowControl" title="Flow Control">Section&nbsp;5.2</a>).
                  </p>
                  <p>From this state either endpoint can send a frame with an END_STREAM flag set, which causes the stream to transition into one
                     of the "half closed" states: an endpoint sending an END_STREAM flag causes the stream state to become "half closed (local)";
                     an endpoint receiving an END_STREAM flag causes the stream state to become "half closed (remote)". A <a href="#HEADERS" class="smpl">HEADERS</a> frame bearing an END_STREAM flag can be followed by <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames. <br><br> Either endpoint can send a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame from this state, causing it to transition immediately to "closed".
                  </p>
               </dd>
               <dt>half closed (local):</dt>
               <dd>
                  <p><br> A stream that is in the "half closed (local)" state cannot be used for sending frames.
                  </p>
                  <p>A stream transitions from this state to "closed" when a frame that contains an END_STREAM flag is received, or when either
                     peer sends a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame. A <a href="#HEADERS" class="smpl">HEADERS</a> frame bearing an END_STREAM flag can be followed by <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames.
                  </p>
                  <p>A receiver can ignore <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> or <a href="#PRIORITY" class="smpl">PRIORITY</a> frames in this state. These frame types might arrive for a short period after a frame bearing the END_STREAM flag is sent.
                  </p>
               </dd>
               <dt>half closed (remote):</dt>
               <dd>
                  <p><br> A stream that is "half closed (remote)" is no longer being used by the peer to send frames. In this state, an endpoint is
                     no longer obligated to maintain a receiver flow control window if it performs flow control.
                  </p>
                  <p>If an endpoint receives additional frames for a stream that is in this state, other than <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames, it MUST respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#STREAM_CLOSED" class="smpl">STREAM_CLOSED</a>.
                  </p>
                  <p>A stream can transition from this state to "closed" by sending a frame that contains a END_STREAM flag, or when either peer
                     sends a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame.
                  </p>
               </dd>
               <dt>closed:</dt>
               <dd>
                  <p><br> The "closed" state is the terminal state.
                  </p>
                  <p>An endpoint MUST NOT send frames on a closed stream. An endpoint that receives any frame after receiving a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> MUST treat that as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#STREAM_CLOSED" class="smpl">STREAM_CLOSED</a>. Similarly, an endpoint that receives any frame after receiving a <a href="#DATA" class="smpl">DATA</a> frame with the END_STREAM flag set, or any frame except a <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frame after receiving a <a href="#HEADERS" class="smpl">HEADERS</a> frame with a END_STREAM flag set MUST treat that as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#STREAM_CLOSED" class="smpl">STREAM_CLOSED</a>.
                  </p>
                  <p><a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a>, <a href="#PRIORITY" class="smpl">PRIORITY</a>, or <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frames can be received in this state for a short period after a <a href="#DATA" class="smpl">DATA</a> or <a href="#HEADERS" class="smpl">HEADERS</a> frame containing an END_STREAM flag is sent. Until the remote peer receives and processes the frame bearing the END_STREAM
                     flag, it might send frame of any of these types. Endpoints MUST ignore <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a>, <a href="#PRIORITY" class="smpl">PRIORITY</a>, or <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frames received in this state, though endpoints MAY choose to treat frames that arrive a significant time after sending END_STREAM
                     as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
                  </p>
                  <p>If this state is reached as a result of sending a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame, the peer that receives the <a href="#RST_STREAM" class="smpl">RST_STREAM</a> might have already sent - or enqueued for sending - frames on the stream that cannot be withdrawn. An endpoint MUST ignore
                     frames that it receives on closed streams after it has sent a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame. An endpoint MAY choose to limit the period over which it ignores frames and treat frames that arrive after this time
                     as being in error.
                  </p>
                  <p>Flow controlled frames (i.e., <a href="#DATA" class="smpl">DATA</a>) received after sending <a href="#RST_STREAM" class="smpl">RST_STREAM</a> are counted toward the connection flow control window. Even though these frames might be ignored, because they are sent before
                     the sender receives the <a href="#RST_STREAM" class="smpl">RST_STREAM</a>, the sender will consider the frames to count against the flow control window.
                  </p>
                  <p>An endpoint might receive a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame after it sends <a href="#RST_STREAM" class="smpl">RST_STREAM</a>. <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> causes a stream to become "reserved". The <a href="#RST_STREAM" class="smpl">RST_STREAM</a> does not cancel any promised stream. Therefore, if promised streams are not desired, a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> can be used to close any of those streams.
                  </p>
               </dd>
            </dl>
            <p id="rfc.section.5.1.p.5">In the absence of more specific guidance elsewhere in this document, implementations SHOULD treat the receipt of a message
               that is not expressly permitted in the description of a state as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
            </p>
            <div id="StreamIdentifiers">
               <h3 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1</a>&nbsp;<a href="#StreamIdentifiers">Stream Identifiers</a></h3>
               <p id="rfc.section.5.1.1.p.1">Streams are identified with an unsigned 31-bit integer. Streams initiated by a client MUST use odd-numbered stream identifiers;
                  those initiated by the server MUST use even-numbered stream identifiers. A stream identifier of zero (0x0) is used for connection
                  control message; the stream identifier zero MUST NOT be used to establish a new stream.
               </p>
               <p id="rfc.section.5.1.1.p.2">A stream identifier of one (0x1) is used to respond to the HTTP/1.1 request which was specified during Upgrade (see <a href="#discover-http" title="Starting HTTP/2.0 for &#34;http&#34; URIs">Section&nbsp;3.2</a>). After the upgrade completes, stream 0x1 is "half closed (local)" to the client. Therefore, stream 0x1 cannot be selected
                  as a new stream identifier by a client that upgrades from HTTP/1.1.
               </p>
               <p id="rfc.section.5.1.1.p.3">The identifier of a newly established stream MUST be numerically greater than all streams that the initiating endpoint has
                  opened or reserved. This governs streams that are opened using a <a href="#HEADERS" class="smpl">HEADERS</a> frame and streams that are reserved using <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a>. An endpoint that receives an unexpected stream identifier MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
               </p>
               <p id="rfc.section.5.1.1.p.4">The first use of a new stream identifier implicitly closes all streams in the "idle" state that might have been initiated
                  by that peer with a lower-valued stream identifier. For example, if a client sends a <a href="#HEADERS" class="smpl">HEADERS</a> frame on stream 7 without ever sending a frame on stream 5, then stream 5 transitions to the "closed" state when the first
                  frame for stream 7 is sent or received.
               </p>
               <p id="rfc.section.5.1.1.p.5">Stream identifiers cannot be reused. Long-lived connections can result in endpoint exhausting the available range of stream
                  identifiers. A client that is unable to establish a new stream identifier can establish a new connection for new streams.
               </p>
            </div>
            <div>
               <h3 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2</a>&nbsp;Stream Concurrency
               </h3>
               <p id="rfc.section.5.1.2.p.1">A peer can limit the number of concurrently active streams using the SETTINGS_MAX_CONCURRENT_STREAMS parameters within a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame. The maximum concurrent streams setting is specific to each endpoint and applies only to the peer that receives the
                  setting. That is, clients specify the maximum number of concurrent streams the server can initiate, and servers specify the
                  maximum number of concurrent streams the client can initiate. Endpoints MUST NOT exceed the limit set by their peer.
               </p>
               <p id="rfc.section.5.1.2.p.2">Streams that are in the "open" state, or either of the "half closed" states count toward the maximum number of streams that
                  an endpoint is permitted to open. Streams in any of these three states count toward the limit advertised in the SETTINGS_MAX_CONCURRENT_STREAMS
                  setting (see <a href="#SettingValues" title="Defined Settings">Section&nbsp;6.5.2</a>).
               </p>
               <p id="rfc.section.5.1.2.p.3">Streams in either of the "reserved" states do not count as open, even if a small amount of application state is retained to
                  ensure that the promised stream can be successfully used.
               </p>
            </div>
         </div>
         <div id="FlowControl">
            <h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2</a>&nbsp;<a href="#FlowControl">Flow Control</a></h2>
            <p id="rfc.section.5.2.p.1">Using streams for multiplexing introduces contention over use of the TCP connection, resulting in blocked streams. A flow
               control scheme ensures that streams on the same connection do not destructively interfere with each other. Flow control is
               used for both individual streams and for the connection as a whole.
            </p>
            <p id="rfc.section.5.2.p.2">HTTP/2.0 provides for flow control through use of the <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> frame type.
            </p>
            <div id="fc-principles">
               <h3 id="rfc.section.5.2.1"><a href="#rfc.section.5.2.1">5.2.1</a>&nbsp;<a href="#fc-principles">Flow Control Principles</a></h3>
               <p id="rfc.section.5.2.1.p.1">HTTP/2.0 stream flow control aims to allow for future improvements to flow control algorithms without requiring protocol changes.
                  Flow control in HTTP/2.0 has the following characteristics: 
               </p>
               <ol>
                  <li>Flow control is hop-by-hop, not end-to-end.</li>
                  <li>Flow control is based on window update frames. Receivers advertise how many bytes they are prepared to receive on a stream
                     and for the entire connection. This is a credit-based scheme.
                  </li>
                  <li>Flow control is directional with overall control provided by the receiver. A receiver MAY choose to set any window size that
                     it desires for each stream and for the entire connection. A sender MUST respect flow control limits imposed by a receiver.
                     Clients, servers and intermediaries all independently advertise their flow control preferences as a receiver and abide by
                     the flow control limits set by their peer when sending.
                  </li>
                  <li>The initial value for the flow control window is 65535 bytes for both new streams and the overall connection.</li>
                  <li>The frame type determines whether flow control applies to a frame. Of the frames specified in this document, only <a href="#DATA" class="smpl">DATA</a> frames are subject to flow control; all other frame types do not consume space in the advertised flow control window. This
                     ensures that important control frames are not blocked by flow control.
                  </li>
                  <li>Flow control can be disabled by a receiver. A receiver can choose to disable both forms of flow control by sending the SETTINGS_FLOW_CONTROL_OPTIONS
                     setting. See Ending Flow Control (<a href="#EndFlowControl" title="Ending Flow Control">Section&nbsp;6.9.4</a>) for more details.
                  </li>
                  <li>HTTP/2.0 standardizes only the format of the <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> frame (<a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">Section&nbsp;6.9</a>). This does not stipulate how a receiver decides when to send this frame or the value that it sends. Nor does it specify
                     how a sender chooses to send packets. Implementations are able to select any algorithm that suits their needs.
                  </li>
               </ol>
               <p id="rfc.section.5.2.1.p.2">Implementations are also responsible for managing how requests and responses are sent based on priority; choosing how to avoid
                  head of line blocking for requests; and managing the creation of new streams. Algorithm choices for these could interact with
                  any flow control algorithm.
               </p>
            </div>
            <div id="DisableFlowControl">
               <h3 id="rfc.section.5.2.2"><a href="#rfc.section.5.2.2">5.2.2</a>&nbsp;<a href="#DisableFlowControl">Appropriate Use of Flow Control</a></h3>
               <p id="rfc.section.5.2.2.p.1">Flow control is defined to protect endpoints that are operating under resource constraints. For example, a proxy needs to
                  share memory between many connections, and also might have a slow upstream connection and a fast downstream one. Flow control
                  addresses cases where the receiver is unable process data on one stream, yet wants to continue to process other streams in
                  the same connection.
               </p>
               <p id="rfc.section.5.2.2.p.2">Deployments that do not require this capability SHOULD disable flow control for data that is being received. Note that flow
                  control cannot be disabled for sending. Sending data is always subject to the flow control window advertised by the receiver.
               </p>
               <p id="rfc.section.5.2.2.p.3">Deployments with constrained resources (for example, memory) MAY employ flow control to limit the amount of memory a peer
                  can consume. Note, however, that this can lead to suboptimal use of available network resources if flow control is enabled
                  without knowledge of the bandwidth-delay product (see <a href="#RFC1323"><cite title="TCP Extensions for High Performance">[RFC1323]</cite></a>).
               </p>
               <p id="rfc.section.5.2.2.p.4">Even with full awareness of the current bandwidth-delay product, implementation of flow control can be difficult. When using
                  flow control, the receive MUST read from the TCP receive buffer in a timely fashion. Failure to do so could lead to a deadlock
                  when critical frames, such as <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a>, are not available to HTTP/2.0. However, flow control can ensure that constrained resources are protected without any reduction
                  in connection utilization.
               </p>
            </div>
         </div>
         <div id="StreamPriority">
            <h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3</a>&nbsp;<a href="#StreamPriority">Stream priority</a></h2>
            <p id="rfc.section.5.3.p.1">The endpoint establishing a new stream can assign a priority for the stream. Priority is represented as an unsigned 31-bit
               integer. 0 represents the highest priority and 2<sup>31</sup>-1 represents the lowest priority.
            </p>
            <p id="rfc.section.5.3.p.2">The purpose of this value is to allow an endpoint to express the relative priority of a stream. An endpoint can use this information
               to preferentially allocate resources to a stream. Within HTTP/2.0, priority can be used to select streams for transmitting
               frames when there is limited capacity for sending. For instance, an endpoint might enqueue frames for all concurrently active
               streams. As transmission capacity becomes available, frames from higher priority streams might be sent before lower priority
               streams.
            </p>
            <p id="rfc.section.5.3.p.3">Explicitly setting the priority for a stream does not guarantee any particular processing or transmission order for the stream
               relative to any other stream. Nor is there any mechanism provided by which the initiator of a stream can force or require
               a receiving endpoint to process concurrent streams in a particular order.
            </p>
            <p id="rfc.section.5.3.p.4">Unless explicitly specified in the <a href="#HEADERS" class="smpl">HEADERS</a> frame (<a href="#HEADERS" title="HEADERS">Section&nbsp;6.2</a>) during stream creation, the default stream priority is 2<sup>30</sup>.
            </p>
            <p id="rfc.section.5.3.p.5">Pushed streams (<a href="#PushResources" title="Server Push">Section&nbsp;8.2</a>) have a lower priority than their associated stream. The promised stream inherits the priority value of the associated stream
               plus one, up to a maximum of 2<sup>31</sup>-1.
            </p>
         </div>
         <div>
            <h2 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4</a>&nbsp;Error Handling
            </h2>
            <p id="rfc.section.5.4.p.1">HTTP/2.0 framing permits two classes of error: </p>
            <ul>
               <li>An error condition that renders the entire connection unusable is a connection error.</li>
               <li>An error in an individual stream is a stream error.</li>
            </ul>
            <p id="rfc.section.5.4.p.2">A list of error codes is included in <a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a>.
            </p>
            <div id="ConnectionErrorHandler">
               <h3 id="rfc.section.5.4.1"><a href="#rfc.section.5.4.1">5.4.1</a>&nbsp;<a href="#ConnectionErrorHandler">Connection Error Handling</a></h3>
               <p id="rfc.section.5.4.1.p.1">A connection error is any error which prevents further processing of the framing layer or which corrupts any connection state.</p>
               <p id="rfc.section.5.4.1.p.2">An endpoint that encounters a connection error SHOULD first send a <a href="#GOAWAY" class="smpl">GOAWAY</a> frame (<a href="#GOAWAY" title="GOAWAY">Section&nbsp;6.8</a>) with the stream identifier of the last stream that it successfully received from its peer. The <a href="#GOAWAY" class="smpl">GOAWAY</a> frame includes an error code that indicates why the connection is terminating. After sending the <a href="#GOAWAY" class="smpl">GOAWAY</a> frame, the endpoint MUST close the TCP connection.
               </p>
               <p id="rfc.section.5.4.1.p.3">It is possible that the <a href="#GOAWAY" class="smpl">GOAWAY</a> will not be reliably received by the receiving endpoint. In the event of a connection error, <a href="#GOAWAY" class="smpl">GOAWAY</a> only provides a best-effort attempt to communicate with the peer about why the connection is being terminated.
               </p>
               <p id="rfc.section.5.4.1.p.4">An endpoint can end a connection at any time. In particular, an endpoint MAY choose to treat a stream error as a connection
                  error. Endpoints SHOULD send a <a href="#GOAWAY" class="smpl">GOAWAY</a> frame when ending a connection, as long as circumstances permit it.
               </p>
            </div>
            <div id="StreamErrorHandler">
               <h3 id="rfc.section.5.4.2"><a href="#rfc.section.5.4.2">5.4.2</a>&nbsp;<a href="#StreamErrorHandler">Stream Error Handling</a></h3>
               <p id="rfc.section.5.4.2.p.1">A stream error is an error related to a specific stream identifier that does not affect processing of other streams.</p>
               <p id="rfc.section.5.4.2.p.2">An endpoint that detects a stream error sends a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame (<a href="#RST_STREAM" title="RST_STREAM">Section&nbsp;6.4</a>) that contains the stream identifier of the stream where the error occurred. The <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame includes an error code that indicates the type of error.
               </p>
               <p id="rfc.section.5.4.2.p.3">A <a href="#RST_STREAM" class="smpl">RST_STREAM</a> is the last frame that an endpoint can send on a stream. The peer that sends the <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame MUST be prepared to receive any frames that were sent or enqueued for sending by the remote peer. These frames can be
                  ignored, except where they modify connection state (such as the state maintained for header compression (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>)).
               </p>
               <p id="rfc.section.5.4.2.p.4">Normally, an endpoint SHOULD NOT send more than one <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame for any stream. However, an endpoint MAY send additional <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frames if it receives frames on a closed stream after more than a round trip time. This behavior is permitted to deal with
                  misbehaving implementations.
               </p>
               <p id="rfc.section.5.4.2.p.5">An endpoint MUST NOT send a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> in response to an <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame, to avoid looping.
               </p>
            </div>
            <div>
               <h3 id="rfc.section.5.4.3"><a href="#rfc.section.5.4.3">5.4.3</a>&nbsp;Connection Termination
               </h3>
               <p id="rfc.section.5.4.3.p.1">If the TCP connection is torn down while streams remain in open or half closed states, then the endpoint MUST assume that
                  the stream was abnormally interrupted and could be incomplete.
               </p>
            </div>
         </div>
      </div>
      <div id="frame-types">
         <h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#frame-types">Frame Definitions</a></h1>
         <p id="rfc.section.6.p.1">This specification defines a number of frame types, each identified by a unique 8-bit type code. Each frame type serves a
            distinct purpose either in the establishment and management of the connection as a whole, or of individual streams.
         </p>
         <p id="rfc.section.6.p.2">The transmission of specific frame types can alter the state of a connection. If endpoints fail to maintain a synchronized
            view of the connection state, successful communication within the connection will no longer be possible. Therefore, it is
            important that endpoints have a shared comprehension of how the state is affected by the use any given frame. Accordingly,
            while it is expected that new frame types will be introduced by extensions to this protocol, only frames defined by this document
            are permitted to alter the connection state.
         </p>
         <div id="DATA">
            <h2 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1</a>&nbsp;<a href="#DATA">DATA</a></h2>
            <p id="rfc.section.6.1.p.1">DATA frames (type=0x0) convey arbitrary, variable-length sequences of octets associated with a stream. One or more DATA frames
               are used, for instance, to carry HTTP request or response payloads.
            </p>
            <p id="rfc.section.6.1.p.2">The DATA frame defines the following flags: </p>
            <dl>
               <dt>END_STREAM (0x1):</dt>
               <dd>Bit 1 being set indicates that this frame is the last that the endpoint will send for the identified stream. Setting this
                  flag causes the stream to enter a "half closed" or "closed" state (<a href="#StreamStates" title="Stream States">Section&nbsp;5.1</a>).
               </dd>
               <dt>RESERVED (0x2):</dt>
               <dd>Bit 2 is reserved for future use.</dd>
            </dl>
            <p id="rfc.section.6.1.p.3">DATA frames MUST be associated with a stream. If a DATA frame is received whose stream identifier field is 0x0, the recipient
               MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
            </p>
            <p id="rfc.section.6.1.p.4">DATA frames are subject to flow control and can only be sent when a stream is in the "open" or "half closed (remote)" states.</p>
         </div>
         <div id="HEADERS">
            <h2 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2</a>&nbsp;<a href="#HEADERS">HEADERS</a></h2>
            <p id="rfc.section.6.2.p.1">The HEADERS frame (type=0x1) carries name-value pairs. It is used to open a stream (<a href="#StreamStates" title="Stream States">Section&nbsp;5.1</a>). HEADERS frames can be sent on a stream in the "open" or "half closed (remote)" states.
            </p>
            <div id="rfc.figure.3"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                        Priority (31)                        |
 +-+-------------------------------------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
            </pre><p class="figure">Figure 3: HEADERS Frame Payload</p>
            <p id="rfc.section.6.2.p.3">The HEADERS frame defines the following flags: </p>
            <dl>
               <dt>END_STREAM (0x1):</dt>
               <dd>
                  <p>Bit 1 being set indicates that this frame is the last that the endpoint will send for the identified stream. Setting this
                     flag causes the stream to enter a "half closed" state (<a href="#StreamStates" title="Stream States">Section&nbsp;5.1</a>).
                  </p>
                  <p>A HEADERS frame that is followed by <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames carries the flag that signals the end of a stream. A <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frame cannot be used to terminate a stream.
                  </p>
               </dd>
               <dt>RESERVED (0x2):</dt>
               <dd>
                  <p>Bit 2 is reserved for future use.</p>
               </dd>
               <dt>END_HEADERS (0x4):</dt>
               <dd>
                  <p>Bit 3 being set indicates that this frame ends the sequence of header block fragments necessary to provide a complete set
                     of headers.
                  </p>
                  <p>The payload for a complete header block is provided by a sequence of that starts with a HEADERS frame, followed by zero or
                     more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames. The sequence is terminated by a frame with the END_HEADERS flag set. Once the sequence terminates, the payload of
                     all HEADERS and <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames are concatenated and interpreted as a single block.
                  </p>
                  <p>A HEADERS frame without the END_HEADERS flag set MUST be followed by a <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frame for the same stream. A receiver MUST treat the receipt of any other type of frame or a frame on a different stream as
                     a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
                  </p>
               </dd>
               <dt>PRIORITY (0x8):</dt>
               <dd>
                  <p>Bit 4 being set indicates that the first four octets of this frame contain a single reserved bit and a 31-bit priority; see <a href="#StreamPriority" title="Stream priority">Section&nbsp;5.3</a>. If this bit is not set, the four bytes do not appear and the frame only contains a header block fragment.
                  </p>
               </dd>
            </dl>
            <p id="rfc.section.6.2.p.4">The payload of a HEADERS frame contains a header block fragment (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>). A header block that does not fit within a HEADERS frame is continued in a CONTINUATION frame (<a href="#CONTINUATION" title="CONTINUATION">Section&nbsp;6.10</a>).
            </p>
            <p id="rfc.section.6.2.p.5">HEADERS frames MUST be associated with a stream. If a HEADERS frame is received whose stream identifier field is 0x0, the
               recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
            </p>
            <p id="rfc.section.6.2.p.6">The HEADERS frame changes the connection state as described in <a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>.
            </p>
         </div>
         <div id="PRIORITY">
            <h2 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3</a>&nbsp;<a href="#PRIORITY">PRIORITY</a></h2>
            <p id="rfc.section.6.3.p.1">The PRIORITY frame (type=0x2) specifies the sender-advised priority of a stream. It can be sent at any time for an existing
               stream. This enables reprioritisation of existing streams.
            </p>
            <div id="rfc.figure.4"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                        Priority (31)                        |
 +-+-------------------------------------------------------------+
            </pre><p class="figure">Figure 4: PRIORITY Frame Payload</p>
            <p id="rfc.section.6.3.p.3">The payload of a PRIORITY frame contains a single reserved bit and a 31-bit priority.</p>
            <p id="rfc.section.6.3.p.4">The PRIORITY frame does not define any flags.</p>
            <p id="rfc.section.6.3.p.5">The PRIORITY frame is associated with an existing stream. If a PRIORITY frame is received with a stream identifier of 0x0,
               the recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
            </p>
            <p id="rfc.section.6.3.p.6">The PRIORITY frame can be sent on a stream in any of the "reserved (remote)", "open", "half-closed (local)", or "half closed
               (remote)" states, though it cannot be sent between consecutive frames that comprise a single header block (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>). Note that this frame could arrive after processing or frame sending has completed, which would cause it to have no effect.
               For a stream that is in the "half closed (remote)" state, this frame can only affect processing of the stream and not frame
               transmission.
            </p>
         </div>
         <div id="RST_STREAM">
            <h2 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4</a>&nbsp;<a href="#RST_STREAM">RST_STREAM</a></h2>
            <p id="rfc.section.6.4.p.1">The RST_STREAM frame (type=0x3) allows for abnormal termination of a stream. When sent by the initiator of a stream, it indicates
               that they wish to cancel the stream or that an error condition has occurred. When sent by the receiver of a stream, it indicates
               that either the receiver is rejecting the stream, requesting that the stream be cancelled or that an error condition has occurred.
            </p>
            <div id="rfc.figure.5"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                        Error Code (32)                        |
 +---------------------------------------------------------------+
            </pre><p class="figure">Figure 5: RST_STREAM Frame Payload</p>
            <p id="rfc.section.6.4.p.3">The RST_STREAM frame contains a single unsigned, 32-bit integer identifying the error code (<a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a>). The error code indicates why the stream is being terminated.
            </p>
            <p id="rfc.section.6.4.p.4">The RST_STREAM frame does not define any flags.</p>
            <p id="rfc.section.6.4.p.5">The RST_STREAM frame fully terminates the referenced stream and causes it to enter the closed state. After receiving a RST_STREAM
               on a stream, the receiver MUST NOT send additional frames for that stream. However, after sending the RST_STREAM, the sending
               endpoint MUST be prepared to receive and process additional frames sent on the stream that might have been sent by the peer
               prior to the arrival of the RST_STREAM.
            </p>
            <p id="rfc.section.6.4.p.6">RST_STREAM frames MUST be associated with a stream. If a RST_STREAM frame is received with a stream identifier of 0x0, the
               recipient MUST treat this as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
            </p>
            <p id="rfc.section.6.4.p.7">RST_STREAM frames MUST NOT be sent for a stream in the "idle" state. If a RST_STREAM frame identifying an idle stream is received,
               the recipient MUST treat this as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
            </p>
         </div>
         <div id="SETTINGS">
            <h2 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5</a>&nbsp;<a href="#SETTINGS">SETTINGS</a></h2>
            <p id="rfc.section.6.5.p.1">The SETTINGS frame (type=0x4) conveys configuration parameters that affect how endpoints communicate. The parameters are either
               constraints on peer behavior or preferences.
            </p>
            <p id="rfc.section.6.5.p.2">SETTINGS frames MUST be sent at the start of a connection, and MAY be sent at any other time by either endpoint over the lifetime
               of the connection.
            </p>
            <p id="rfc.section.6.5.p.3">Implementations MUST support all of the settings defined by this specification and MAY support additional settings defined
               by extensions. Unsupported or unrecognized settings MUST be ignored. New settings MUST NOT be defined or implemented in a
               way that requires endpoints to understand them in order to communicate successfully.
            </p>
            <p id="rfc.section.6.5.p.4">Each setting in a SETTINGS frame replaces the existing value for that setting. Settings are processed in the order in which
               they appear, and a receiver of a SETTINGS frame does not need to maintain any state other than the current value of settings.
               Therefore, the value of a setting is the last value that is seen by a receiver. This permits the inclusion of the same settings
               multiple times in the same SETTINGS frame, though doing so does nothing other than waste connection capacity.
            </p>
            <p id="rfc.section.6.5.p.5">The SETTINGS frame defines the following flag: </p>
            <dl>
               <dt>ACK (0x1):</dt>
               <dd>Bit 1 being set indicates that this frame acknowledges receipt and application of the peer's SETTINGS frame. When this bit
                  is set, the payload of the SETTINGS frame MUST be empty. Receipt of a SETTINGS frame with the ACK flag set and a length field
                  value other than 0 MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#FRAME_SIZE_ERROR" class="smpl">FRAME_SIZE_ERROR</a>. For more info, see Settings Synchronization (<a href="#SettingsSync" title="Settings Synchronization">Section&nbsp;6.5.3</a>).
               </dd>
            </dl>
            <p id="rfc.section.6.5.p.6">SETTINGS frames always apply to a connection, never a single stream. The stream identifier for a settings frame MUST be zero.
               If an endpoint receives a SETTINGS frame whose stream identifier field is anything other than 0x0, the endpoint MUST respond
               with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
            </p>
            <p id="rfc.section.6.5.p.7">The SETTINGS frame affects connection state. A badly formed or incomplete SETTINGS frame MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
            </p>
            <div id="SettingFormat">
               <h3 id="rfc.section.6.5.1"><a href="#rfc.section.6.5.1">6.5.1</a>&nbsp;<a href="#SettingFormat">Setting Format</a></h3>
               <p id="rfc.section.6.5.1.p.1">The payload of a SETTINGS frame consists of zero or more settings. Each setting consists of an 8-bit reserved field, an unsigned
                  24-bit setting identifier, and an unsigned 32-bit value.
               </p>
               <div id="rfc.figure.6"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Reserved (8) |            Setting Identifier (24)            |
 +---------------+-----------------------------------------------+
 |                        Value (32)                             |
 +---------------------------------------------------------------+
              </pre><p class="figure">Figure 6: Setting Format</p>
            </div>
            <div id="SettingValues">
               <h3 id="rfc.section.6.5.2"><a href="#rfc.section.6.5.2">6.5.2</a>&nbsp;<a href="#SettingValues">Defined Settings</a></h3>
               <p id="rfc.section.6.5.2.p.1">The following settings are defined: </p>
               <dl>
                  <dt>SETTINGS_HEADER_TABLE_SIZE (1):</dt>
                  <dd>
                     <p>Allows the sender to inform the remote endpoint of the size of the header compression table used to decode header blocks.
                        The default value is 4096 bytes.
                     </p>
                  </dd>
                  <dt>SETTINGS_ENABLE_PUSH (2):</dt>
                  <dd>
                     <p>This setting can be use to disable server push (<a href="#PushResources" title="Server Push">Section&nbsp;8.2</a>). An endpoint MUST NOT send a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame if it receives this setting set to a value of 0. The default value is 1, which indicates that push is permitted.
                     </p>
                  </dd>
                  <dt>SETTINGS_MAX_CONCURRENT_STREAMS (4):</dt>
                  <dd>
                     <p>Indicates the maximum number of concurrent streams that the sender will allow. This limit is directional: it applies to the
                        number of streams that the sender permits the receiver to create. By default there is no limit. It is recommended that this
                        value be no smaller than 100, so as to not unnecessarily limit parallelism.
                     </p>
                  </dd>
                  <dt>SETTINGS_INITIAL_WINDOW_SIZE (7):</dt>
                  <dd>
                     <p>Indicates the sender's initial window size (in bytes) for stream level flow control.</p>
                     <p>This settings affects the window size of all streams, including existing streams, see <a href="#InitialWindowSize" title="Initial Flow Control Window Size">Section&nbsp;6.9.2</a>.
                     </p>
                  </dd>
                  <dt>SETTINGS_FLOW_CONTROL_OPTIONS (10):</dt>
                  <dd>
                     <p>Indicates flow control options. The least significant bit (0x1) of the value is set to indicate that the sender has disabled
                        all flow control. This bit cannot be cleared once set, see <a href="#EndFlowControl" title="Ending Flow Control">Section&nbsp;6.9.4</a>.
                     </p>
                     <p>All bits other than the least significant are reserved.</p>
                  </dd>
               </dl>
            </div>
            <div id="SettingsSync">
               <h3 id="rfc.section.6.5.3"><a href="#rfc.section.6.5.3">6.5.3</a>&nbsp;<a href="#SettingsSync">Settings Synchronization</a></h3>
               <p id="rfc.section.6.5.3.p.1">Most values in SETTINGS benefit from or require an understanding of when the peer has received and applied the changed setting
                  values. In order to provide such synchronization timepoints, the recipient of a SETTINGS frame in which the ACK flag is not
                  set MUST apply the updated settings as soon as possible upon receipt.
               </p>
               <p id="rfc.section.6.5.3.p.2">The values in the SETTINGS frame MUST be applied in sequence, with no other frame processing between values. Once all values
                  have been applied, the recipient MUST immediately emit a SETTINGS frame with the ACK flag set.
               </p>
               <p id="rfc.section.6.5.3.p.3">If the sender of a SETTINGS frame does not receive an acknowledgement within a reasonable amount of time, it MAY issue a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#SETTINGS_TIMEOUT" class="smpl">SETTINGS_TIMEOUT</a>.
               </p>
            </div>
         </div>
         <div id="PUSH_PROMISE">
            <h2 id="rfc.section.6.6"><a href="#rfc.section.6.6">6.6</a>&nbsp;<a href="#PUSH_PROMISE">PUSH_PROMISE</a></h2>
            <p id="rfc.section.6.6.p.1">The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint in advance of streams the sender intends to initiate.
               The PUSH_PROMISE frame includes the unsigned 31-bit identifier of the stream the endpoint plans to create along with a minimal
               set of headers that provide additional context for the stream. <a href="#PushResources" title="Server Push">Section&nbsp;8.2</a> contains a thorough description of the use of PUSH_PROMISE frames.
            </p>
            <p id="rfc.section.6.6.p.2">PUSH_PROMISE MUST NOT be sent if the SETTINGS_ENABLE_PUSH setting of the peer endpoint is set to 0.</p>
            <div id="rfc.figure.7"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                Promised-Stream-ID (31)                      |
 +-+-------------------------------------------------------------+
 |                 Header Block Fragment (*)                   ...
 +---------------------------------------------------------------+
            </pre><p class="figure">Figure 7: PUSH_PROMISE Payload Format</p>
            <p id="rfc.section.6.6.p.4">The payload of a PUSH_PROMISE includes a "Promised-Stream-ID". This unsigned 31-bit integer identifies the stream the endpoint
               intends to start sending frames for. The promised stream identifier MUST be a valid choice for the next stream sent by the
               sender (see new stream identifier (<a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>)).
            </p>
            <p id="rfc.section.6.6.p.5">Following the "Promised-Stream-ID" is a header block fragment (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>).
            </p>
            <p id="rfc.section.6.6.p.6">PUSH_PROMISE frames MUST be associated with an existing, peer-initiated stream. If the stream identifier field specifies the
               value 0x0, a recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
            </p>
            <p id="rfc.section.6.6.p.7">The PUSH_PROMISE frame defines the following flags: </p>
            <dl>
               <dt>END_PUSH_PROMISE (0x4):</dt>
               <dd>
                  <p>The END_PUSH_PROMISE bit indicates that this frame ends the sequence of header block fragments necessary to provide a complete
                     set of headers.
                  </p>
                  <p>The payload for a complete header block is provided by a sequence of frames that starts with a PUSH_PROMISE frame, followed
                     by zero or more CONTINUATION frames. The sequence terminates by a PUSH_PROMISE frame with the END_PUSH_PROMISE flag set or
                     a CONTINUATION frame with the END_HEADERS flag set. Once the sequence terminates, the payload of all frames in the sequence
                     are concatenated and interpreted as a single block.
                  </p>
                  <p>A PUSH_PROMISE frame without the END_PUSH_PROMISE flag set MUST be followed by a CONTINUATION frame for the same stream. A
                     receiver MUST treat the receipt of any other type of frame or a frame on a different stream as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
                  </p>
               </dd>
            </dl>
            <p id="rfc.section.6.6.p.8">Promised streams are not required to be used in order promised. The PUSH_PROMISE only reserves stream identifiers for later
               use.
            </p>
            <p id="rfc.section.6.6.p.9">Recipients of PUSH_PROMISE frames can choose to reject promised streams by returning a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> referencing the promised stream identifier back to the sender of the PUSH_PROMISE.
            </p>
            <p id="rfc.section.6.6.p.10">The PUSH_PROMISE frame modifies the connection state as defined in <a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>.
            </p>
            <p id="rfc.section.6.6.p.11">A PUSH_PROMISE frame modifies the connection state in two ways. The inclusion of a header block (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>) potentially modifies the compression state. PUSH_PROMISE also reserves a stream for later use, causing the promised stream
               to enter the "reserved" state. A sender MUST NOT send a PUSH_PROMISE on a stream unless that stream is either "open" or "half
               closed (remote)"; the sender MUST ensure that the promised stream is a valid choice for a new stream identifier (<a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>) (that is, the promised stream MUST be in the "idle" state).
            </p>
            <p id="rfc.section.6.6.p.12">Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame causes the stream state to become indeterminate. A receiver
               MUST treat the receipt of a PUSH_PROMISE on a stream that is neither "open" nor "half-closed (local)" as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>. Similarly, a receiver MUST treat the receipt of a PUSH_PROMISE that promises an illegal stream identifier (<a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>) (that is, an identifier for a stream that is not currently in the "idle" state) as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>, unless the receiver recently sent a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame to cancel the associated stream (see <a href="#StreamStates" title="Stream States">Section&nbsp;5.1</a>).
            </p>
         </div>
         <div id="PING">
            <h2 id="rfc.section.6.7"><a href="#rfc.section.6.7">6.7</a>&nbsp;<a href="#PING">PING</a></h2>
            <p id="rfc.section.6.7.p.1">The PING frame (type=0x6) is a mechanism for measuring a minimal round-trip time from the sender, as well as determining whether
               an idle connection is still functional. PING frames can be sent from any endpoint.
            </p>
            <div id="rfc.figure.8"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 |                      Opaque Data (64)                         |
 |                                                               |
 +---------------------------------------------------------------+
            </pre><p class="figure">Figure 8: PING Payload Format</p>
            <p id="rfc.section.6.7.p.3">In addition to the frame header, PING frames MUST contain 8 octets of data in the payload. A sender can include any value
               it chooses and use those bytes in any fashion.
            </p>
            <p id="rfc.section.6.7.p.4">Receivers of a PING frame that does not include a ACK flag MUST send a PING frame with the ACK flag set in response, with
               an identical payload. PING responses SHOULD given higher priority than any other frame.
            </p>
            <p id="rfc.section.6.7.p.5">The PING frame defines the following flags: </p>
            <dl>
               <dt>ACK (0x1):</dt>
               <dd>Bit 1 being set indicates that this PING frame is a PING response. An endpoint MUST set this flag in PING responses. An endpoint
                  MUST NOT respond to PING frames containing this flag.
               </dd>
            </dl>
            <p id="rfc.section.6.7.p.6">PING frames are not associated with any individual stream. If a PING frame is received with a stream identifier field value
               other than 0x0, the recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
            </p>
            <p id="rfc.section.6.7.p.7">Receipt of a PING frame with a length field value other than 8 MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#FRAME_SIZE_ERROR" class="smpl">FRAME_SIZE_ERROR</a>.
            </p>
         </div>
         <div id="GOAWAY">
            <h2 id="rfc.section.6.8"><a href="#rfc.section.6.8">6.8</a>&nbsp;<a href="#GOAWAY">GOAWAY</a></h2>
            <p id="rfc.section.6.8.p.1">The GOAWAY frame (type=0x7) informs the remote peer to stop creating streams on this connection. It can be sent from the client
               or the server. Once sent, the sender will ignore frames sent on new streams for the remainder of the connection. Receivers
               of a GOAWAY frame MUST NOT open additional streams on the connection, although a new connection can be established for new
               streams. The purpose of this frame is to allow an endpoint to gracefully stop accepting new streams (perhaps for a reboot
               or maintenance), while still finishing processing of previously established streams.
            </p>
            <p id="rfc.section.6.8.p.2">There is an inherent race condition between an endpoint starting new streams and the remote sending a GOAWAY frame. To deal
               with this case, the GOAWAY contains the stream identifier of the last stream which was processed on the sending endpoint in
               this connection. If the receiver of the GOAWAY used streams that are newer than the indicated stream identifier, they were
               not processed by the sender and the receiver may treat the streams as though they had never been created at all (hence the
               receiver may want to re-create the streams later on a new connection).
            </p>
            <p id="rfc.section.6.8.p.3">Endpoints SHOULD always send a GOAWAY frame before closing a connection so that the remote can know whether a stream has been
               partially processed or not. For example, if an HTTP client sends a POST at the same time that a server closes a connection,
               the client cannot know if the server started to process that POST request if the server does not send a GOAWAY frame to indicate
               where it stopped working. An endpoint might choose to close a connection without sending GOAWAY for misbehaving peers.
            </p>
            <p id="rfc.section.6.8.p.4">After sending a GOAWAY frame, the sender can discard frames for new streams. However, any frames that alter connection state
               cannot be completely ignored. For instance, <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> and <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames MUST be minimally processed to ensure a consistent compression state (see <a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>); similarly DATA frames MUST be counted toward the connection flow control window.
            </p>
            <div id="rfc.figure.9"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                  Last-Stream-ID (31)                        |
 +-+-------------------------------------------------------------+
 |                      Error Code (32)                          |
 +---------------------------------------------------------------+
 |                  Additional Debug Data (*)                    |
 +---------------------------------------------------------------+
            </pre><p class="figure">Figure 9: GOAWAY Payload Format</p>
            <p id="rfc.section.6.8.p.6">The GOAWAY frame does not define any flags.</p>
            <p id="rfc.section.6.8.p.7">The GOAWAY frame applies to the connection, not a specific stream. The stream identifier MUST be zero.</p>
            <p id="rfc.section.6.8.p.8">The last stream identifier in the GOAWAY frame contains the highest numbered stream identifier for which the sender of the
               GOAWAY frame has received frames on and might have taken some action on. All streams up to and including the identified stream
               might have been processed in some way. The last stream identifier is set to 0 if no streams were processed. 
            </p>
            <ul class="empty">
               <li>Note: In this case, "processed" means that some data from the stream was passed to some higher layer of software that might
                  have taken some action as a result.
               </li>
            </ul>
            <p> If a connection terminates without a GOAWAY frame, this value is effectively the highest stream identifier.</p>
            <p id="rfc.section.6.8.p.9">On streams with lower or equal numbered identifiers that were not closed completely prior to the connection being closed,
               re-attempting requests, transactions, or any protocol activity is not possible (with the exception of idempotent actions like
               HTTP GET, PUT, or DELETE). Any protocol activity that uses higher numbered streams can be safely retried using a new connection.
            </p>
            <p id="rfc.section.6.8.p.10">Activity on streams numbered lower or equal to the last stream identifier might still complete successfully. The sender of
               a GOAWAY frame might gracefully shut down a connection by sending a GOAWAY frame, maintaining the connection in an open state
               until all in-progress streams complete.
            </p>
            <p id="rfc.section.6.8.p.11">The last stream ID MUST be 0 if no streams were acted upon.</p>
            <p id="rfc.section.6.8.p.12">The GOAWAY frame also contains a 32-bit error code (<a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a>) that contains the reason for closing the connection.
            </p>
            <p id="rfc.section.6.8.p.13">Endpoints MAY append opaque data to the payload of any GOAWAY frame. Additional debug data is intended for diagnostic purposes
               only and carries no semantic value. Debug data MUST NOT be persistently stored, since it could contain sensitive information.
            </p>
         </div>
         <div id="WINDOW_UPDATE">
            <h2 id="rfc.section.6.9"><a href="#rfc.section.6.9">6.9</a>&nbsp;<a href="#WINDOW_UPDATE">WINDOW_UPDATE</a></h2>
            <p id="rfc.section.6.9.p.1">The WINDOW_UPDATE frame (type=0x9) is used to implement flow control.</p>
            <p id="rfc.section.6.9.p.2">Flow control operates at two levels: on each individual stream and on the entire connection.</p>
            <p id="rfc.section.6.9.p.3">Both types of flow control are hop by hop; that is, only between the two endpoints. Intermediaries do not forward WINDOW_UPDATE
               frames between dependent connections. However, throttling of data transfer by any receiver can indirectly cause the propagation
               of flow control information toward the original sender.
            </p>
            <p id="rfc.section.6.9.p.4">Flow control only applies to frames that are identified as being subject to flow control. Of the frame types defined in this
               document, this includes only <a href="#DATA" class="smpl">DATA</a> frame. Frames that are exempt from flow control MUST be accepted and processed, unless the receiver is unable to assign resources
               to handling the frame. A receiver MAY respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) or connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#FLOW_CONTROL_ERROR" class="smpl">FLOW_CONTROL_ERROR</a> if it is unable accept a frame.
            </p>
            <div id="rfc.figure.10"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|              Window Size Increment (31)                     |
 +-+-------------------------------------------------------------+
            </pre><p class="figure">Figure 10: WINDOW_UPDATE Payload Format</p>
            <p id="rfc.section.6.9.p.6">The payload of a WINDOW_UPDATE frame is one reserved bit, plus an unsigned 31-bit integer indicating the number of bytes that
               the sender can transmit in addition to the existing flow control window. The legal range for the increment to the flow control
               window is 1 to 2<sup>31</sup> - 1 (0x7fffffff) bytes.
            </p>
            <p id="rfc.section.6.9.p.7">The WINDOW_UPDATE frame does not define any flags.</p>
            <p id="rfc.section.6.9.p.8">The WINDOW_UPDATE frame can be specific to a stream or to the entire connection. In the former case, the frame's stream identifier
               indicates the affected stream; in the latter, the value "0" indicates that the entire connection is the subject of the frame.
            </p>
            <p id="rfc.section.6.9.p.9">WINDOW_UPDATE can be sent by a peer that has sent a frame bearing the END_STREAM flag. This means that a receiver could receive
               a WINDOW_UPDATE frame on a "half closed (remote)" or "closed" stream. A receiver MUST NOT treat this as an error, see <a href="#StreamStates" title="Stream States">Section&nbsp;5.1</a>.
            </p>
            <p id="rfc.section.6.9.p.10">A receiver that receives a flow controlled frame MUST always account for its contribution against the connection flow control
               window, unless the receiver treats this as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>). This is necessary even if the frame is in error. Since the sender counts the frame toward the flow control window, if the
               receiver does not, the flow control window at sender and receiver can become different.
            </p>
            <div>
               <h3 id="rfc.section.6.9.1"><a href="#rfc.section.6.9.1">6.9.1</a>&nbsp;The Flow Control Window
               </h3>
               <p id="rfc.section.6.9.1.p.1">Flow control in HTTP/2.0 is implemented using a window kept by each sender on every stream. The flow control window is a simple
                  integer value that indicates how many bytes of data the sender is permitted to transmit; as such, its size is a measure of
                  the buffering capability of the receiver.
               </p>
               <p id="rfc.section.6.9.1.p.2">Two flow control windows are applicable: the stream flow control window and the connection flow control window. The sender
                  MUST NOT send a flow controlled frame with a length that exceeds the space available in either of the flow control windows
                  advertised by the receiver. Frames with zero length with the END_STREAM flag set (for example, an empty data frame) MAY be
                  sent if there is no available space in either flow control window.
               </p>
               <p id="rfc.section.6.9.1.p.3">For flow control calculations, the 8 byte frame header is not counted.</p>
               <p id="rfc.section.6.9.1.p.4">After sending a flow controlled frame, the sender reduces the space available in both windows by the length of the transmitted
                  frame.
               </p>
               <p id="rfc.section.6.9.1.p.5">The receiver of a frame sends a WINDOW_UPDATE frame as it consumes data and frees up space in flow control windows. Separate
                  WINDOW_UPDATE frames are sent for the stream and connection level flow control windows.
               </p>
               <p id="rfc.section.6.9.1.p.6">A sender that receives a WINDOW_UPDATE frame updates the corresponding window by the amount specified in the frame.</p>
               <p id="rfc.section.6.9.1.p.7">A sender MUST NOT allow a flow control window to exceed 2<sup>31</sup> - 1 bytes. If a sender receives a WINDOW_UPDATE that causes a flow control window to exceed this maximum it MUST terminate
                  either the stream or the connection, as appropriate. For streams, the sender sends a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> with the error code of <a href="#FLOW_CONTROL_ERROR" class="smpl">FLOW_CONTROL_ERROR</a> code; for the connection, a <a href="#GOAWAY" class="smpl">GOAWAY</a> frame with a <a href="#FLOW_CONTROL_ERROR" class="smpl">FLOW_CONTROL_ERROR</a> code.
               </p>
               <p id="rfc.section.6.9.1.p.8">Flow controlled frames from the sender and WINDOW_UPDATE frames from the receiver are completely asynchronous with respect
                  to each other. This property allows a receiver to aggressively update the window size kept by the sender to prevent streams
                  from stalling.
               </p>
            </div>
            <div id="InitialWindowSize">
               <h3 id="rfc.section.6.9.2"><a href="#rfc.section.6.9.2">6.9.2</a>&nbsp;<a href="#InitialWindowSize">Initial Flow Control Window Size</a></h3>
               <p id="rfc.section.6.9.2.p.1">When a HTTP/2.0 connection is first established, new streams are created with an initial flow control window size of 65535
                  bytes. The connection flow control window is 65535 bytes. Both endpoints can adjust the initial window size for new streams
                  by including a value for SETTINGS_INITIAL_WINDOW_SIZE in the <a href="#SETTINGS" class="smpl">SETTINGS</a> frame that forms part of the connection header.
               </p>
               <p id="rfc.section.6.9.2.p.2">Prior to receiving a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame that sets a value for SETTINGS_INITIAL_WINDOW_SIZE, an endpoint can only use the default initial window size when sending
                  flow controlled frames. Similarly, the connection flow control window is set to the default initial window size until a WINDOW_UPDATE
                  frame is received.
               </p>
               <p id="rfc.section.6.9.2.p.3">A <a href="#SETTINGS" class="smpl">SETTINGS</a> frame can alter the initial flow control window size for all current streams. When the value of SETTINGS_INITIAL_WINDOW_SIZE
                  changes, a receiver MUST adjust the size of all stream flow control windows that it maintains by the difference between the
                  new value and the old value. A <a href="#SETTINGS" class="smpl">SETTINGS</a> frame cannot alter the connection flow control window.
               </p>
               <p id="rfc.section.6.9.2.p.4">A change to SETTINGS_INITIAL_WINDOW_SIZE could cause the available space in a flow control window to become negative. A sender
                  MUST track the negative flow control window, and MUST NOT send new flow controlled frames until it receives WINDOW_UPDATE
                  frames that cause the flow control window to become positive.
               </p>
               <p id="rfc.section.6.9.2.p.5">For example, if the client sends 60KB immediately on connection establishment, and the server sets the initial window size
                  to be 16KB, the client will recalculate the available flow control window to be -44KB on receipt of the <a href="#SETTINGS" class="smpl">SETTINGS</a> frame. The client retains a negative flow control window until WINDOW_UPDATE frames restore the window to being positive,
                  after which the client can resume sending.
               </p>
            </div>
            <div>
               <h3 id="rfc.section.6.9.3"><a href="#rfc.section.6.9.3">6.9.3</a>&nbsp;Reducing the Stream Window Size
               </h3>
               <p id="rfc.section.6.9.3.p.1">A receiver that wishes to use a smaller flow control window than the current size can send a new <a href="#SETTINGS" class="smpl">SETTINGS</a> frame. However, the receiver MUST be prepared to receive data that exceeds this window size, since the sender might send data
                  that exceeds the lower limit prior to processing the <a href="#SETTINGS" class="smpl">SETTINGS</a> frame.
               </p>
               <p id="rfc.section.6.9.3.p.2">A receiver has two options for handling streams that exceed flow control limits: </p>
               <ol>
                  <li>The receiver can immediately send <a href="#RST_STREAM" class="smpl">RST_STREAM</a> with <a href="#FLOW_CONTROL_ERROR" class="smpl">FLOW_CONTROL_ERROR</a> error code for the affected streams.
                  </li>
                  <li>The receiver can accept the streams and tolerate the resulting head of line blocking, sending WINDOW_UPDATE frames as it consumes
                     data.
                  </li>
               </ol>
               <p> If a receiver decides to accept streams, both sides MUST recompute the available flow control window based on the initial
                  window size sent in the <a href="#SETTINGS" class="smpl">SETTINGS</a>.
               </p>
            </div>
            <div id="EndFlowControl">
               <h3 id="rfc.section.6.9.4"><a href="#rfc.section.6.9.4">6.9.4</a>&nbsp;<a href="#EndFlowControl">Ending Flow Control</a></h3>
               <p id="rfc.section.6.9.4.p.1">After a receiver reads in a frame that marks the end of a stream (for example, a data stream with a END_STREAM flag set),
                  it MUST cease transmission of WINDOW_UPDATE frames for that stream. A sender is not obligated to maintain the available flow
                  control window for streams that it is no longer sending on.
               </p>
               <p id="rfc.section.6.9.4.p.2">Flow control can be disabled for the entire connection using the SETTINGS_FLOW_CONTROL_OPTIONS setting. This setting ends
                  all forms of flow control. An implementation that does not wish to perform flow control can use this in the initial <a href="#SETTINGS" class="smpl">SETTINGS</a> exchange.
               </p>
               <p id="rfc.section.6.9.4.p.3">Flow control cannot be enabled again once disabled. Any attempt to re-enable flow control - by sending a WINDOW_UPDATE or
                  by clearing the bits on the SETTINGS_FLOW_CONTROL_OPTIONS setting - MUST be rejected with a <a href="#FLOW_CONTROL_ERROR" class="smpl">FLOW_CONTROL_ERROR</a> error code.
               </p>
            </div>
         </div>
         <div id="CONTINUATION">
            <h2 id="rfc.section.6.10"><a href="#rfc.section.6.10">6.10</a>&nbsp;<a href="#CONTINUATION">CONTINUATION</a></h2>
            <p id="rfc.section.6.10.p.1">The CONTINUATION frame (type=0xA) is used to continue a sequence of header block fragments (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>). Any number of CONTINUATION frames can be sent on an existing stream, as long as the preceding frame on the same stream is
               one of <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> or CONTINUATION.
            </p>
            <div id="rfc.figure.11"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
</pre><p class="figure">Figure 11: CONTINUATION Frame Payload</p>
            <p id="rfc.section.6.10.p.3">The CONTINUATION frame defines the following flags: </p>
            <dl>
               <dt>END_HEADERS (0x4):</dt>
               <dd>
                  <p>The END_HEADERS bit indicates that this frame ends the sequence of header block fragments necessary to provide a complete
                     set of headers.
                  </p>
                  <p>The payload for a complete header block is provided by a sequence that starts with a <a href="#HEADERS" class="smpl">HEADERS</a> or <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame and zero or more CONTINUATION frames, terminated by a <a href="#HEADERS" class="smpl">HEADERS</a> or CONTINUATION frame with the END_HEADERS flag set, or <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame with the END_PUSH_PROMISE flag set. Once the sequence terminates, the payload of all frames in the sequence are concatenated
                     and interpreted as a single block.
                  </p>
                  <p>A <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a>, or CONTINUATION frame without the END_HEADERS flag set MUST be followed by a CONTINUATION frame for the same stream. A receiver
                     MUST treat the receipt of any other type of frame or a frame on a different stream as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
                  </p>
               </dd>
            </dl>
            <p id="rfc.section.6.10.p.4">The payload of a CONTINUATION frame contains a header block fragment (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>).
            </p>
            <p id="rfc.section.6.10.p.5">The CONTINUATION frame changes the connection state as defined in <a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>.
            </p>
            <p id="rfc.section.6.10.p.6">CONTINUATION frames MUST be associated with a stream. If a CONTINUATION frame is received whose stream identifier field is
               0x0, the recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type PROTOCOL_ERROR.
            </p>
            <p id="rfc.section.6.10.p.7">A CONTINUATION frame MUST be preceded by a <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> or CONTINUATION frame. A recipient that observes violation of this rule MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
            </p>
         </div>
      </div>
      <div id="ErrorCodes">
         <h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a>&nbsp;<a href="#ErrorCodes">Error Codes</a></h1>
         <p id="rfc.section.7.p.1">Error codes are 32-bit fields that are used in <a href="#RST_STREAM" class="smpl">RST_STREAM</a> and <a href="#GOAWAY" class="smpl">GOAWAY</a> frames to convey the reasons for the stream or connection error.
         </p>
         <p id="rfc.section.7.p.2">Error codes share a common code space. Some error codes only apply to specific conditions and have no defined semantics in
            certain frame types.
         </p>
         <p id="rfc.section.7.p.3">The following error codes are defined: </p>
         <dl>
            <dt id="NO_ERROR">NO_ERROR (0):</dt>
            <dd>The associated condition is not as a result of an error. For example, a <a href="#GOAWAY" class="smpl">GOAWAY</a> might include this code to indicate graceful shutdown of a connection.
            </dd>
            <dt id="PROTOCOL_ERROR">PROTOCOL_ERROR (1):</dt>
            <dd>The endpoint detected an unspecific protocol error. This error is for use when a more specific error code is not available.</dd>
            <dt id="INTERNAL_ERROR">INTERNAL_ERROR (2):</dt>
            <dd>The endpoint encountered an unexpected internal error.</dd>
            <dt id="FLOW_CONTROL_ERROR">FLOW_CONTROL_ERROR (3):</dt>
            <dd>The endpoint detected that its peer violated the flow control protocol.</dd>
            <dt id="SETTINGS_TIMEOUT">SETTINGS_TIMEOUT (4):</dt>
            <dd>The endpoint sent a SETTINGS frame, but did not receive a response in a timely manner. See Settings Synchronization (<a href="#SettingsSync" title="Settings Synchronization">Section&nbsp;6.5.3</a>).
            </dd>
            <dt id="STREAM_CLOSED">STREAM_CLOSED (5):</dt>
            <dd>The endpoint received a frame after a stream was half closed.</dd>
            <dt id="FRAME_SIZE_ERROR">FRAME_SIZE_ERROR (6):</dt>
            <dd>The endpoint received a frame that was larger than the maximum size that it supports.</dd>
            <dt id="REFUSED_STREAM">REFUSED_STREAM (7):</dt>
            <dd>The endpoint refuses the stream prior to performing any application processing, see <a href="#Reliability" title="Request Reliability Mechanisms in HTTP/2.0">Section&nbsp;8.1.3</a> for details.
            </dd>
            <dt id="CANCEL">CANCEL (8):</dt>
            <dd>Used by the endpoint to indicate that the stream is no longer needed.</dd>
            <dt id="COMPRESSION_ERROR">COMPRESSION_ERROR (9):</dt>
            <dd>The endpoint is unable to maintain the compression context for the connection.</dd>
            <dt id="CONNECT_ERROR">CONNECT_ERROR (10):</dt>
            <dd>The connection established in response to a CONNECT request (<a href="#CONNECT" title="The CONNECT Method">Section&nbsp;8.3</a>) was reset or abnormally closed.
            </dd>
            <dt id="ENHANCE_YOUR_CALM">ENHANCE_YOUR_CALM (420):</dt>
            <dd>The endpoint detected that its peer is exhibiting a behavior over a given amount of time that has caused it to refuse to process
               further frames.
            </dd>
         </dl>
      </div>
      <div id="HTTPLayer">
         <h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a>&nbsp;<a href="#HTTPLayer">HTTP Message Exchanges</a></h1>
         <p id="rfc.section.8.p.1">HTTP/2.0 is intended to be as compatible as possible with current web-based applications. This means that, from the perspective
            of the server business logic or application API, the features of HTTP are unchanged. To achieve this, all of the application
            request and response header semantics are preserved, although the syntax of conveying those semantics has changed. Thus, the
            rules from HTTP/1.1 (<a href="#HTTP-p1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>, <a href="#HTTP-p2"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[HTTP-p2]</cite></a>, <a href="#HTTP-p4"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[HTTP-p4]</cite></a>, <a href="#HTTP-p5"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Range Requests">[HTTP-p5]</cite></a>, <a href="#HTTP-p6"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[HTTP-p6]</cite></a>, and <a href="#HTTP-p7"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[HTTP-p7]</cite></a>) apply with the changes in the sections below.
         </p>
         <div id="HttpSequence">
            <h2 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1</a>&nbsp;<a href="#HttpSequence">HTTP Request/Response Exchange</a></h2>
            <p id="rfc.section.8.1.p.1">A client sends an HTTP request on a new stream, using a previously unused stream identifier (<a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>). A server sends an HTTP response on the same stream as the request.
            </p>
            <p id="rfc.section.8.1.p.2">An HTTP request or response each consist of: </p>
            <ol>
               <li>a <a href="#HEADERS" class="smpl">HEADERS</a> frame;
               </li>
               <li>one contiguous sequence of zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames;
               </li>
               <li>zero or more <a href="#DATA" class="smpl">DATA</a> frames; and
               </li>
               <li>optionally, a contiguous sequence that starts with a <a href="#HEADERS" class="smpl">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames.
               </li>
            </ol>
            <p> The last frame in the sequence bears an END_STREAM flag, though a <a href="#HEADERS" class="smpl">HEADERS</a> frame bearing the END_STREAM flag can be followed by <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames that carry any remaining portions of the header block.
            </p>
            <p id="rfc.section.8.1.p.3">Other frames MAY be interspersed with these frames, but those frames do not carry HTTP semantics. In particular, <a href="#HEADERS" class="smpl">HEADERS</a> frames (and any <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames that follow) other than the first and optional last frames in this sequence do not carry HTTP semantics.
            </p>
            <p id="rfc.section.8.1.p.4">Trailing header fields are carried in a header block that also terminates the stream. That is, a sequence starting with a <a href="#HEADERS" class="smpl">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames, where the <a href="#HEADERS" class="smpl">HEADERS</a> frame bears an END_STREAM flag. Header blocks after the first that do not terminate the stream are not part of an HTTP request
               or response.
            </p>
            <p id="rfc.section.8.1.p.5">An HTTP request/response exchange fully consumes a single stream. A request starts with the <a href="#HEADERS" class="smpl">HEADERS</a> frame that puts the stream into an "open" state and ends with a frame bearing END_STREAM, which causes the stream to become
               "half closed" for the client. A response starts with a <a href="#HEADERS" class="smpl">HEADERS</a> frame and ends with a frame bearing END_STREAM, which places the stream in the "closed" state.
            </p>
            <div>
               <h3 id="rfc.section.8.1.1"><a href="#rfc.section.8.1.1">8.1.1</a>&nbsp;Examples
               </h3>
               <p id="rfc.section.8.1.1.p.1">This section shows HTTP/1.1 requests and responses, with illustrations of equivalent HTTP/2.0 requests and responses.</p>
               <p id="rfc.section.8.1.1.p.2">An HTTP GET request includes request header fields and no body and is therefore transmitted as a single contiguous sequence
                  of <a href="#HEADERS" class="smpl">HEADERS</a> frames containing the serialized block of request header fields. The last <a href="#HEADERS" class="smpl">HEADERS</a> frame in the sequence has both the END_HEADERS and END_STREAM flag set:
               </p>
               <div id="rfc.figure.u.6"></div><pre class="inline">  GET /resource HTTP/1.1         HEADERS
  Host: example.org        ==&gt;     + END_STREAM
  Accept: image/jpeg               + END_HEADERS
                                     :method = GET
                                     :scheme = https
                                     :authority = example.org
                                     :path = /resource
                                     accept = image/jpeg
</pre><p id="rfc.section.8.1.1.p.4">Similarly, a response that includes only response header fields is transmitted as a sequence of <a href="#HEADERS" class="smpl">HEADERS</a> frames containing the serialized block of response header fields. The last <a href="#HEADERS" class="smpl">HEADERS</a> frame in the sequence has both the END_HEADERS and END_STREAM flag set:
               </p>
               <div id="rfc.figure.u.7"></div><pre class="inline">  HTTP/1.1 204 No Content       HEADERS 
  Content-Length: 0        ===&gt;   + END_STREAM
                                  + END_HEADERS
                                    :status = 204
                                    content-length: 0
</pre><p id="rfc.section.8.1.1.p.6">An HTTP POST request that includes request header fields and payload data is transmitted as one <a href="#HEADERS" class="smpl">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames, containing the request headers followed by one or more <a href="#DATA" class="smpl">DATA</a> frames, with the last <a href="#CONTINUATION" class="smpl">CONTINUATION</a> (or <a href="#HEADERS" class="smpl">HEADERS</a>) frame having the END_HEADERS flag set and the final <a href="#DATA" class="smpl">DATA</a> frame having the END_STREAM flag set:
               </p>
               <div id="rfc.figure.u.8"></div><pre class="inline">  POST /resource HTTP/1.1        HEADERS 
  Host: example.org         ==&gt;    - END_STREAM
  Content-Type: image/jpeg         + END_HEADERS
  Content-Length: 123                :method = POST
                                     :scheme = https
  {binary data}                      :authority = example.org
                                     :path = /resource
                                     content-type = image/jpeg
                                     content-length = 123

                                 DATA 
                                   + END_STREAM
                                     {binary data}
</pre><p id="rfc.section.8.1.1.p.8">A response that includes header fields and payload data is transmitted as a <a href="#HEADERS" class="smpl">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames, followed by one or more <a href="#DATA" class="smpl">DATA</a> frames, with the last <a href="#DATA" class="smpl">DATA</a> frame in the sequence having the END_STREAM flag set:
               </p>
               <div id="rfc.figure.u.9"></div><pre class="inline">  HTTP/1.1 200 OK                HEADERS 
  Content-Type: image/jpeg  ==&gt;    - END_STREAM
  Content-Length: 123              + END_HEADERS
                                     :status = 200
  {binary data}                      content-type = image/jpeg
                                     content-length = 123
                                    
                                 DATA 
                                   + END_STREAM
                                     {binary data}
</pre><p id="rfc.section.8.1.1.p.10">Trailing header fields are sent as a header block after both the request or response header block and all the <a href="#DATA" class="smpl">DATA</a> frames have been sent. The sequence of <a href="#HEADERS" class="smpl">HEADERS</a>/<a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames that bears the trailers includes a terminal frame that has both END_HEADERS and END_STREAM flags set.
               </p>
               <div id="rfc.figure.u.10"></div><pre class="inline">  HTTP/1.1 200 OK               HEADERS 
  Content-Type: image/jpeg ===&gt;   - END_STREAM
  Content-Length: 123             + END_HEADERS 
  Transfer-Encoding: chunked        :status        = 200
  TE: trailers                      content-length = 123
  123                               content-type   = image/jpeg
  {binary data}                     
  0                             DATA 
  Foo: bar                        - END_STREAM 
                                    {binary data}
  
                                HEADERS 
                                  + END_STREAM
                                  + END_HEADERS
                                    foo: bar
</pre></div>
            <div id="HttpHeaders">
               <h3 id="rfc.section.8.1.2"><a href="#rfc.section.8.1.2">8.1.2</a>&nbsp;<a href="#HttpHeaders">HTTP Header Fields</a></h3>
               <p id="rfc.section.8.1.2.p.1">HTTP/2.0 request and response header fields carry information as a series of key-value pairs. This includes the target URI
                  for the request, the status code for the response, as well as HTTP header fields.
               </p>
               <p id="rfc.section.8.1.2.p.2">HTTP header field names are strings of ASCII characters that are compared in a case-insensitive fashion. Note that header
                  compression could cause case information to be lost.
               </p>
               <p id="rfc.section.8.1.2.p.3">The semantics of HTTP header fields are not altered by this specification, though header fields relating to connection management
                  or request framing are no longer necessary. An HTTP/2.0 request or response MUST NOT include any of the following header fields:
                  Connection, Keep-Alive, Proxy-Connection, TE, Transfer-Encoding, and Upgrade. A server MUST treat the presence of any of these
                  header fields as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>. 
               </p>
               <dl>
                  <dt>Note:</dt>
                  <dd>HTTP/2.0 purposefully does not support upgrade from HTTP/2.0 to another protocol. The handshake methods described in <a href="#starting" title="Starting HTTP/2.0">Section&nbsp;3</a> are sufficient to negotiate the use of alternative protocols.
                  </dd>
               </dl>
               <div id="HttpRequest">
                  <h4 id="rfc.section.8.1.2.1"><a href="#rfc.section.8.1.2.1">8.1.2.1</a>&nbsp;<a href="#HttpRequest">Request Header Fields</a></h4>
                  <p id="rfc.section.8.1.2.1.p.1">HTTP/2.0 defines a number of headers starting with a colon ':' character that carry information about the request target: </p>
                  <ul>
                     <li>
                        <p>The <samp>:method</samp> header field includes the HTTP method (<a href="#HTTP-p2"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[HTTP-p2]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p2-semantics.html#methods" title="Request Methods">Section 4</a>).
                        </p>
                     </li>
                     <li>
                        <p>The <samp>:scheme</samp> header field includes the scheme portion of the target URI (<a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>, <a href="http://tools.ietf.org/html/rfc3986#section-3.1">Section 3.1</a>).
                        </p>
                     </li>
                     <li>
                        <p>The <samp>:authority</samp> header field includes the authority portion of the target URI (<a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>, <a href="http://tools.ietf.org/html/rfc3986#section-3.2">Section 3.2</a>).
                        </p>
                        <p>To ensure that the HTTP/1.1 request line can be reproduced accurately, this header field MUST be omitted when translating
                           from an HTTP/1.1 request that has a request target in origin or asterisk form (see <a href="#HTTP-p1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p1-messaging.html#request-target" title="Request Target">Section 5.3</a>). Clients that generate HTTP/2.0 requests directly SHOULD instead omit the <samp>Host</samp> header. An intermediary that converts a request to HTTP/1.1 MUST create a <samp>Host</samp> header field if one is not present in a request by copying the value of the <samp>:authority</samp> header field.
                        </p>
                     </li>
                     <li>
                        <p>The <samp>:path</samp> header field includes the path and query parts of the target URI (the <samp>path-absolute</samp> production from <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a> and optionally a '?' character followed by the <samp>query</samp> production, see <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>, <a href="http://tools.ietf.org/html/rfc3986#section-3.3">Section 3.3</a> and <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>, <a href="http://tools.ietf.org/html/rfc3986#section-3.4">Section 3.4</a>). This field MUST NOT be empty; URIs that do not contain a path component MUST include a value of '/', unless the request
                           is an OPTIONS in asterisk form, in which case the <samp>:path</samp> header field MUST include '*'.
                        </p>
                     </li>
                  </ul>
                  <p> All HTTP/2.0 requests MUST include exactly one valid value for all of these header fields, unless this is a CONNECT request (<a href="#CONNECT" title="The CONNECT Method">Section&nbsp;8.3</a>). An HTTP request that omits mandatory headers is malformed. Intermediaries that do not interpret requests MAY forward a malformed
                     request. Implementations that detect malformed requests need to ensure that the stream ends, however a server MAY send an
                     HTTP response prior to closing or resetting the stream.
                  </p>
                  <p id="rfc.section.8.1.2.1.p.2">Header field names that contain a colon are only valid in the HTTP/2.0 context. These are not HTTP header fields. Implementations
                     MUST NOT generate header fields that start with a colon, but they MUST ignore any header field that starts with a colon. In
                     particular, header fields with names starting with a colon MUST NOT be exposed as HTTP header fields.
                  </p>
                  <p id="rfc.section.8.1.2.1.p.3">HTTP/2.0 does not define a way to carry the version identifier that is included in the HTTP/1.1 request line.</p>
                  <p id="rfc.section.8.1.2.1.p.4">All HTTP Requests that include a body can include a <samp>content-length</samp> header field. If a server receives a request where the sum of the <a href="#DATA" class="smpl">DATA</a> frame payload lengths does not equal the value of the <samp>content-length</samp> header field, the server MUST return a 400 (Bad Request) error.
                  </p>
               </div>
               <div id="HttpResponse">
                  <h4 id="rfc.section.8.1.2.2"><a href="#rfc.section.8.1.2.2">8.1.2.2</a>&nbsp;<a href="#HttpResponse">Response Header Fields</a></h4>
                  <p id="rfc.section.8.1.2.2.p.1">A single <samp>:status</samp> header field is defined that carries the HTTP status code field (see <a href="#HTTP-p2"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[HTTP-p2]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p2-semantics.html#status.codes" title="Response Status Codes">Section 6</a>). This header field MUST be included in all responses. Intermediaries that do not interpret requests MAY forward a response
                     that is malformed in this fashion. Clients MUST NOT accept a malformed response.
                  </p>
                  <p id="rfc.section.8.1.2.2.p.2">HTTP/2.0 does not define a way to carry the version or reason phrase that is included in an HTTP/1.1 status line.</p>
               </div>
            </div>
            <div id="Reliability">
               <h3 id="rfc.section.8.1.3"><a href="#rfc.section.8.1.3">8.1.3</a>&nbsp;<a href="#Reliability">Request Reliability Mechanisms in HTTP/2.0</a></h3>
               <p id="rfc.section.8.1.3.p.1">In HTTP/1.1, an HTTP client is unable to retry a non-idempotent request when an error occurs, because there is no means to
                  determine the nature of the error. It is possible that some server processing occurred prior to the error, which could result
                  in undesirable effects if the request were reattempted.
               </p>
               <p id="rfc.section.8.1.3.p.2">HTTP/2.0 provides two mechanisms for providing a guarantee to a client that a request has not been processed: </p>
               <ul>
                  <li>The <a href="#GOAWAY" class="smpl">GOAWAY</a> frame indicates the highest stream number that might have been processed. Requests on streams with higher numbers are therefore
                     guaranteed to be safe to retry.
                  </li>
                  <li>The <a href="#REFUSED_STREAM" class="smpl">REFUSED_STREAM</a> error code can be included in a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame to indicate that the stream is being closed prior to any processing having occurred. Any request that was sent on the
                     reset stream can be safely retried.
                  </li>
               </ul>
               <p id="rfc.section.8.1.3.p.3">Clients MUST NOT treat requests that have not been processed as having failed. Clients MAY automatically retry these requests,
                  including those with non-idempotent methods.
               </p>
               <p id="rfc.section.8.1.3.p.4">A server MUST NOT indicate that a stream has not been processed unless it can guarantee that fact. If frames that are on a
                  stream are passed to the application layer for any stream, then <a href="#REFUSED_STREAM" class="smpl">REFUSED_STREAM</a> MUST NOT be used for that stream, and a <a href="#GOAWAY" class="smpl">GOAWAY</a> frame MUST include a stream identifier that is greater than or equal to the given stream identifier.
               </p>
               <p id="rfc.section.8.1.3.p.5">In addition to these mechanisms, the <a href="#PING" class="smpl">PING</a> frame provides a way for a client to easily test a connection. Connections that remain idle can become broken as some middleboxes
                  (for instance, network address translators, or load balancers) silently discard connection bindings. The <a href="#PING" class="smpl">PING</a> frame allows a client to safely test whether a connection is still active without sending a request.
               </p>
            </div>
         </div>
         <div id="PushResources">
            <h2 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2</a>&nbsp;<a href="#PushResources">Server Push</a></h2>
            <p id="rfc.section.8.2.p.1">HTTP/2.0 enables a server to pre-emptively send (or "push") multiple associated resources to a client in response to a single
               request. This feature becomes particularly helpful when the server knows the client will need to have those resources available
               in order to fully process the originally requested resource.
            </p>
            <p id="rfc.section.8.2.p.2">Pushing additional resources is optional, and is negotiated only between individual endpoints. The SETTINGS_ENABLE_PUSH setting
               can be set to 0 to indicate that server push is disabled. Even if enabled, an intermediary could receive pushed resources
               from the server but could choose not to forward those on to the client. How to make use of the pushed resources is up to that
               intermediary. Equally, the intermediary might choose to push additional resources to the client, without any action taken
               by the server.
            </p>
            <p id="rfc.section.8.2.p.3">A server can only push requests that are safe (see <a href="#HTTP-p2"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[HTTP-p2]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p2-semantics.html#safe.methods" title="Safe Methods">Section 4.2.1</a>), cacheable (see <a href="#HTTP-p6"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[HTTP-p6]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p6-cache.html#response.cacheability" title="Storing Responses in Caches">Section 3</a>) and do not include a request body.
            </p>
            <div>
               <h3 id="rfc.section.8.2.1"><a href="#rfc.section.8.2.1">8.2.1</a>&nbsp;Push Requests
               </h3>
               <p id="rfc.section.8.2.1.p.1">Server push is semantically equivalent to a server responding to a request. The <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame, or frames, sent by the server includes a header block that contains a complete set of request headers that the server
                  attributes to the request. It is not possible to push a response to a request that includes a request body.
               </p>
               <p id="rfc.section.8.2.1.p.2">Pushed resources are always associated with an explicit request from a client. The <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames sent by the server are sent on the stream created for the original request. The <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame includes a promised stream identifier, chosen from the stream identifiers available to the server (see <a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>).
               </p>
               <p id="rfc.section.8.2.1.p.3">The header fields in <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> and any subsequent <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames MUST be a valid and complete set of request headers (<a href="#HttpRequest" title="Request Header Fields">Section&nbsp;8.1.2.1</a>). The server MUST include a method in the <samp>:method</samp> header field that is safe and cacheable. If a client receives a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> that does not include a complete and valid set of header fields, or the <samp>:method</samp> header field identifies a method that is not safe, it MUST respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.
               </p>
               <p id="rfc.section.8.2.1.p.4">The server SHOULD send <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> (<a href="#PUSH_PROMISE" title="PUSH_PROMISE">Section&nbsp;6.6</a>) frames prior to sending any frames that reference the promised resources. This avoids a race where clients issue requests
                  for resources prior to receiving any <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames.
               </p>
               <p id="rfc.section.8.2.1.p.5">For example, if the server receives a request for a document containing embedded links to multiple image files, and the server
                  chooses to push those additional images to the client, sending push promises before the <a href="#DATA" class="smpl">DATA</a> frames that contain the image links ensure that the client is able to see the promises before discovering the resources. Similarly,
                  if the server pushes resources referenced by the header block (for instance, in Link header fields), sending the push promises
                  before sending the header block ensures that clients do not request those resources.
               </p>
               <p id="rfc.section.8.2.1.p.6"><a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames MUST NOT be sent by the client. <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames can be sent by the server on any stream that was opened by the client. They MUST be sent on a stream that is in either
                  the "open" or "half closed (remote)" state to the server. <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames are interspersed with the frames that comprise a response, though they cannot be interspersed with <a href="#HEADERS" class="smpl">HEADERS</a> and <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames that comprise a single header block.
               </p>
            </div>
            <div>
               <h3 id="rfc.section.8.2.2"><a href="#rfc.section.8.2.2">8.2.2</a>&nbsp;Push Responses
               </h3>
               <p id="rfc.section.8.2.2.p.1">After sending the <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame, the server can begin delivering the pushed resource as a response (<a href="#HttpResponse" title="Response Header Fields">Section&nbsp;8.1.2.2</a>) on a server-initiated stream that uses the promised stream identifier. The server uses this stream to transmit an HTTP response,
                  using the same sequence of frames as defined in <a href="#HttpSequence" title="HTTP Request/Response Exchange">Section&nbsp;8.1</a>. This stream becomes "half closed" to the client (<a href="#StreamStates" title="Stream States">Section&nbsp;5.1</a>) after the initial <a href="#HEADERS" class="smpl">HEADERS</a> frame is sent.
               </p>
               <p id="rfc.section.8.2.2.p.2">Once a client receives a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame and chooses to accept the pushed resource, the client SHOULD NOT issue any requests for the promised resource until
                  after the promised stream has closed.
               </p>
               <p id="rfc.section.8.2.2.p.3">If the client determines, for any reason, that it does not wish to receive the pushed resource from the server, or if the
                  server takes too long to begin sending the promised resource, the client can send an <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame, using either the <a href="#CANCEL" class="smpl">CANCEL</a> or <a href="#REFUSED_STREAM" class="smpl">REFUSED_STREAM</a> codes, and referencing the pushed stream's identifier.
               </p>
               <p id="rfc.section.8.2.2.p.4">A client can use the SETTINGS_MAX_CONCURRENT_STREAMS setting to limit the number of resources that can be concurrently pushed
                  by a server. Advertising a SETTINGS_MAX_CONCURRENT_STREAMS value of zero disables server push by preventing the server from
                  creating the necessary streams. This does not prohibit a server from sending PUSH_PROMISE frames; clients need to reset any
                  promised streams that are not wanted.
               </p>
               <p id="rfc.section.8.2.2.p.5">Clients receiving a pushed response MUST validate that the server is authorized to push the resource using the same-origin
                  policy (<a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a>, <a href="http://tools.ietf.org/html/rfc6454#section-3">Section 3</a>). For example, a HTTP/2.0 connection to <samp>example.com</samp> is generally <span class="comment" id="rfc.comment.2">[<a href="#rfc.comment.2" class="smpl">rfc.comment.2</a>: Ed: weaselly use of "generally", needs better definition]</span> not permitted to push a response for <samp>www.example.org</samp>.
               </p>
            </div>
         </div>
         <div id="CONNECT">
            <h2 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3</a>&nbsp;<a href="#CONNECT">The CONNECT Method</a></h2>
            <p id="rfc.section.8.3.p.1">The HTTP pseudo-method CONNECT (<a href="#HTTP-p2"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[HTTP-p2]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p2-semantics.html#CONNECT" title="CONNECT">Section 4.3.6</a>) is used to convert an HTTP/1.1 connection into a tunnel to a remote host. CONNECT is primarily used with HTTP proxies to
               established a TLS session with a server for the purposes of interacting with <samp>https</samp> resources.
            </p>
            <p id="rfc.section.8.3.p.2">In HTTP/2.0, the CONNECT method is used to establish a tunnel over a single HTTP/2.0 stream to a remote host. The HTTP header
               mapping works as mostly as defined in Request Header Fields (<a href="#HttpRequest" title="Request Header Fields">Section&nbsp;8.1.2.1</a>), with a few differences. Specifically: 
            </p>
            <ul>
               <li>The <samp>:method</samp> header field is set to <samp>CONNECT</samp>.
               </li>
               <li>The <samp>:scheme</samp> and <samp>:path</samp> header fields MUST be omitted.
               </li>
               <li>The <samp>:authority</samp> header field contains the host and port to connect to (equivalent to the authority-form of the request-target of CONNECT requests,
                  see <a href="#HTTP-p1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p1-messaging.html#request-target" title="Request Target">Section 5.3</a>).
               </li>
            </ul>
            <p id="rfc.section.8.3.p.3">A proxy that supports CONNECT, establishes a <a href="#TCP">TCP connection</a> <cite title="Transmission Control Protocol">[TCP]</cite> to the server identified in the <samp>:path</samp> header field. Once this connection is successfully established, the proxy sends a <a href="#HEADERS" class="smpl">HEADERS</a> frame containing a 2xx series status code, as defined in <a href="#HTTP-p2"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[HTTP-p2]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p2-semantics.html#CONNECT" title="CONNECT">Section 4.3.6</a>.
            </p>
            <p id="rfc.section.8.3.p.4">After the initial <a href="#HEADERS" class="smpl">HEADERS</a> frame sent by each peer, all subsequent <a href="#DATA" class="smpl">DATA</a> frames correspond to data sent on the TCP connection. The payload of any <a href="#DATA" class="smpl">DATA</a> frames sent by the client are transmitted by the proxy to the TCP server; data received from the TCP server is assembled into <a href="#DATA" class="smpl">DATA</a> frames by the proxy. Frame types other than <a href="#DATA" class="smpl">DATA</a> or stream management frames (<a href="#RST_STREAM" class="smpl">RST_STREAM</a>, <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a>, and <a href="#PRIORITY" class="smpl">PRIORITY</a>) MUST NOT be sent on a connected stream, and MUST be treated as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) if received.
            </p>
            <p id="rfc.section.8.3.p.5">The TCP connection can be closed by either peer. The END_STREAM flag on a <a href="#DATA" class="smpl">DATA</a> frame is treated as being equivalent to the TCP FIN bit. A client is expected to send a <a href="#DATA" class="smpl">DATA</a> frame with the END_STREAM flag set after receiving a frame bearing the END_STREAM flag. A proxy that receives a <a href="#DATA" class="smpl">DATA</a> frame with the END_STREAM flag set sends the attached data with the FIN bit set on the last TCP segment. A proxy that receives
               a TCP segment with the FIN bit set sends a <a href="#DATA" class="smpl">DATA</a> frame with the END_STREAM flag set. Note that the final TCP segment or <a href="#DATA" class="smpl">DATA</a> frame could be empty.
            </p>
            <p id="rfc.section.8.3.p.6">A TCP connection error is signaled with <a href="#RST_STREAM" class="smpl">RST_STREAM</a>. A proxy treats any error in the TCP connection, which includes receiving a TCP segment with the RST bit set, as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#CONNECT_ERROR" class="smpl">CONNECT_ERROR</a>. Correspondingly, a proxy MUST send a TCP segment with the RST bit set if it detects an error with the stream or the HTTP/2.0
               connection.
            </p>
         </div>
      </div>
      <div id="HttpExtra">
         <h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a>&nbsp;<a href="#HttpExtra">Additional HTTP Requirements/Considerations</a></h1>
         <p id="rfc.section.9.p.1">This section outlines attributes of the HTTP protocol that improve interoperability, reduce exposure to known security vulnerabilities,
            or reduce the potential for implementation variation.
         </p>
         <div>
            <h2 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1</a>&nbsp;Connection Management
            </h2>
            <p id="rfc.section.9.1.p.1">HTTP/2.0 connections are persistent. For best performance, it is expected clients will not close connections until it is determined
               that no further communication with a server is necessary (for example, when a user navigates away from a particular web page),
               or until the server closes the connection.
            </p>
            <p id="rfc.section.9.1.p.2">Clients SHOULD NOT open more than one HTTP/2.0 connection to a given origin (<a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a>) concurrently. A client can create additional connections as replacements, either to replace connections that are near to
               exhausting the available stream identifiers (<a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>), or to replace connections that have encountered errors (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>).
            </p>
            <p id="rfc.section.9.1.p.3">Servers are encouraged to maintain open connections for as long as possible, but are permitted to terminate idle connections
               if necessary. When either endpoint chooses to close the transport-level TCP connection, the terminating endpoint SHOULD first
               send a <a href="#GOAWAY" class="smpl">GOAWAY</a> (<a href="#GOAWAY" title="GOAWAY">Section&nbsp;6.8</a>) frame so that both endpoints can reliably determine whether previously sent frames have been processed and gracefully complete
               or terminate any necessary remaining tasks.
            </p>
         </div>
         <div>
            <h2 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2</a>&nbsp;Use of TLS Features
            </h2>
            <p id="rfc.section.9.2.p.1">Implementations of HTTP/2.0 MUST support <a href="#TLS11">TLS 1.1</a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.1">[TLS11]</cite>. <span class="comment" id="rfc.comment.3">[<a href="#rfc.comment.3" class="smpl">rfc.comment.3</a>: The working group intends to require at least the use of <a href="#TLS12">TLS 1.2</a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[TLS12]</cite> prior to publication of this document; negotiating TLS 1.1 is permitted to enable the creation of interoperable implementations
                  of early drafts.]</span> 
            </p>
            <p id="rfc.section.9.2.p.2">The TLS implementation MUST support the <a href="#TLS-EXT">Server Name Indication (SNI)</a> <cite title="Transport Layer Security (TLS) Extensions: Extension Definitions">[TLS-EXT]</cite> extension to TLS. HTTP/2.0 clients MUST indicate the target domain name when negotiating TLS.
            </p>
            <p id="rfc.section.9.2.p.3">A server that receives a TLS handshake that does not include either TLS 1.1 or SNI, MUST NOT negotiate HTTP/2.0. Removing
               HTTP/2.0 protocols from consideration could result in the removal of all protocols from the set of protocols offered by the
               client. This causes protocol negotiation failure, as described in <a href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg-02#section-3.2">Section 3.2</a> of <a href="#TLSALPN"><cite title="Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension">[TLSALPN]</cite></a>.
            </p>
            <p id="rfc.section.9.2.p.4">Implementations are encouraged not to negotiate TLS cipher suites with known vulnerabilities, such as <a href="#RC4"><cite title="The RC4 encryption algorithm">[RC4]</cite></a>.
            </p>
         </div>
         <div id="Compression">
            <h2 id="rfc.section.9.3"><a href="#rfc.section.9.3">9.3</a>&nbsp;<a href="#Compression">GZip Content-Encoding</a></h2>
            <p id="rfc.section.9.3.p.1">Clients MUST support gzip compression for HTTP response bodies. Regardless of the value of the accept-encoding header field,
               a server MAY send responses with gzip or deflate encoding. A compressed response MUST still bear an appropriate content-encoding
               header field.
            </p>
         </div>
      </div>
      <div id="security">
         <h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a>&nbsp;<a href="#security">Security Considerations</a></h1>
         <div>
            <h2 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1</a>&nbsp;Server Authority and Same-Origin
            </h2>
            <p id="rfc.section.10.1.p.1">This specification uses the same-origin policy (<a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a>, <a href="http://tools.ietf.org/html/rfc6454#section-3">Section 3</a>) to determine whether an origin server is permitted to provide content.
            </p>
            <p id="rfc.section.10.1.p.2">A server that is contacted using TLS is authenticated based on the certificate that it offers in the TLS handshake (see <a href="#RFC2818"><cite title="HTTP Over TLS">[RFC2818]</cite></a>, <a href="http://tools.ietf.org/html/rfc2818#section-3">Section 3</a>). A server is considered authoritative for an "https" resource if it has been successfully authenticated for the domain part
               of the origin of the resource that it is providing.
            </p>
            <p id="rfc.section.10.1.p.3">A server is considered authoritative for an "http" resource if the connection is established to a resolved IP address for
               the domain in the origin of the resource.
            </p>
            <p id="rfc.section.10.1.p.4">A client MUST NOT use, in any way, resources provided by a server that is not authoritative for those resources.</p>
         </div>
         <div>
            <h2 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2</a>&nbsp;Cross-Protocol Attacks
            </h2>
            <p id="rfc.section.10.2.p.1">When using TLS, we believe that HTTP/2.0 introduces no new cross-protocol attacks. TLS encrypts the contents of all transmission
               (except the handshake itself), making it difficult for attackers to control the data which could be used in a cross-protocol
               attack. <span class="comment" id="rfc.comment.4">[<a href="#rfc.comment.4" class="smpl">rfc.comment.4</a>: Issue: This is no longer true]</span> 
            </p>
         </div>
         <div>
            <h2 id="rfc.section.10.3"><a href="#rfc.section.10.3">10.3</a>&nbsp;Intermediary Encapsulation Attacks
            </h2>
            <p id="rfc.section.10.3.p.1">HTTP/2.0 header field names and values are encoded as sequences of octets with a length prefix. This enables HTTP/2.0 to carry
               any string of octets as the name or value of a header field. An intermediary that translates HTTP/2.0 requests or responses
               into HTTP/1.1 directly could permit the creation of corrupted HTTP/1.1 messages. An attacker might exploit this behavior to
               cause the intermediary to create HTTP/1.1 messages with illegal header fields, extra header fields, or even new messages that
               are entirely falsified.
            </p>
            <p id="rfc.section.10.3.p.2">An intermediary that performs translation into HTTP/1.1 cannot alter the semantics of requests or responses. In particular,
               header field names or values that contain characters not permitted by HTTP/1.1, including carriage return (U+000D) or line
               feed (U+000A) MUST NOT be translated verbatim, as stipulated in <a href="#HTTP-p1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p1-messaging.html#field.parsing" title="Field Parsing">Section 3.2.4</a>.
            </p>
            <p id="rfc.section.10.3.p.3">Translation from HTTP/1.x to HTTP/2.0 does not produce the same opportunity to an attacker. Intermediaries that perform translation
               to HTTP/2.0 MUST remove any instances of the <samp>obs-fold</samp> production from header field values.
            </p>
         </div>
         <div>
            <h2 id="rfc.section.10.4"><a href="#rfc.section.10.4">10.4</a>&nbsp;Cacheability of Pushed Resources
            </h2>
            <p id="rfc.section.10.4.p.1">Pushed resources are responses without an explicit request; the request for a pushed resource is synthesized from the request
               that triggered the push, plus resource identification information provided by the server. Request header fields are necessary
               for HTTP cache control validations (such as the Vary header field) to work. For this reason, caches MUST inherit request header
               fields from the associated stream for the push. This includes the Cookie header field.
            </p>
            <p id="rfc.section.10.4.p.2">Caching resources that are pushed is possible, based on the guidance provided by the origin server in the Cache-Control header
               field. However, this can cause issues if a single server hosts more than one tenant. For example, a server might offer multiple
               users each a small portion of its URI space.
            </p>
            <p id="rfc.section.10.4.p.3">Where multiple tenants share space on the same server, that server MUST ensure that tenants are not able to push representations
               of resources that they do not have authority over. Failure to enforce this would allow a tenant to provide a representation
               that would be served out of cache, overriding the actual representation that the authoritative tenant provides.
            </p>
            <p id="rfc.section.10.4.p.4">Pushed resources for which an origin server is not authoritative are never cached or used.</p>
         </div>
      </div>
      <div>
         <h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a>&nbsp;Privacy Considerations
         </h1>
         <p id="rfc.section.11.p.1">HTTP/2.0 aims to keep connections open longer between clients and servers in order to reduce the latency when a user makes
            a request. The maintenance of these connections over time could be used to expose private information. For example, a user
            using a browser hours after the previous user stopped using that browser may be able to learn about what the previous user
            was doing. This is a problem with HTTP in its current form as well, however the short lived connections make it less of a
            risk.
         </p>
      </div>
      <div id="iana">
         <h1 id="rfc.section.12"><a href="#rfc.section.12">12.</a>&nbsp;<a href="#iana">IANA Considerations</a></h1>
         <p id="rfc.section.12.p.1">A string for identifying HTTP/2.0 is entered into the "Application Layer Protocol Negotiation (ALPN) Protocol IDs" registry
            established in <a href="#TLSALPN"><cite title="Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension">[TLSALPN]</cite></a>.
         </p>
         <p id="rfc.section.12.p.2">This document establishes registries for frame types, error codes and settings. These new registries are entered in a new
            "Hypertext Transfer Protocol (HTTP) 2.0 Parameters" section.
         </p>
         <p id="rfc.section.12.p.3">This document registers the <samp>HTTP2-Settings</samp> header field for use in HTTP.
         </p>
         <div id="iana-alpn">
            <h2 id="rfc.section.12.1"><a href="#rfc.section.12.1">12.1</a>&nbsp;<a href="#iana-alpn">Registration of HTTP/2.0 Identification String</a></h2>
            <p id="rfc.section.12.1.p.1">This document creates a registration for the identification of HTTP/2.0 in the "Application Layer Protocol Negotiation (ALPN)
               Protocol IDs" registry established in <a href="#TLSALPN"><cite title="Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension">[TLSALPN]</cite></a>. 
            </p>
            <dl>
               <dt>Protocol:</dt>
               <dd>HTTP/2.0</dd>
               <dt>Identification Sequence:</dt>
               <dd>0x48 0x54 0x54 0x50 0x2f 0x32 0x2e 0x30 ("HTTP/2.0")</dd>
               <dt>Specification:</dt>
               <dd>This document (RFCXXXX)</dd>
            </dl>
         </div>
         <div>
            <h2 id="rfc.section.12.2"><a href="#rfc.section.12.2">12.2</a>&nbsp;Frame Type Registry
            </h2>
            <p id="rfc.section.12.2.p.1">This document establishes a registry for HTTP/2.0 frame types. The "HTTP/2.0 Frame Type" registry operates under the <a href="#RFC5226">"IETF Review" policy</a> <cite title="Guidelines for Writing an IANA Considerations Section in RFCs">[RFC5226]</cite>.
            </p>
            <p id="rfc.section.12.2.p.2">Frame types are an 8-bit value. When reviewing new frame type registrations, special attention is advised for any frame type-specific
               flags that are defined. Frame flags can interact with existing flags and could prevent the creation of globally applicable
               flags.
            </p>
            <p id="rfc.section.12.2.p.3">Initial values for the "HTTP/2.0 Frame Type" registry are shown in <a href="#IanaInitialFrameType">Table&nbsp;1</a>.
            </p>
            <div id="rfc.table.1">
               <div id="IanaInitialFrameType"></div>
               <table class="tt full center" cellpadding="3" cellspacing="0">
                  <caption>Table 1</caption>
                  <thead>
                     <tr>
                        <th>Frame Type</th>
                        <th>Name</th>
                        <th>Flags</th>
                        <th>Section</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td class="left">0</td>
                        <td class="left"><a href="#DATA" class="smpl">DATA</a></td>
                        <td class="left">END_STREAM(1)</td>
                        <td class="left"><a href="#DATA" title="DATA">Section&nbsp;6.1</a></td>
                     </tr>
                     <tr>
                        <td class="left">1</td>
                        <td class="left"><a href="#HEADERS" class="smpl">HEADERS</a></td>
                        <td class="left">END_STREAM(1), END_HEADERS(4), PRIORITY(8)</td>
                        <td class="left"><a href="#HEADERS" title="HEADERS">Section&nbsp;6.2</a></td>
                     </tr>
                     <tr>
                        <td class="left">2</td>
                        <td class="left"><a href="#PRIORITY" class="smpl">PRIORITY</a></td>
                        <td class="left">-</td>
                        <td class="left"><a href="#PRIORITY" title="PRIORITY">Section&nbsp;6.3</a></td>
                     </tr>
                     <tr>
                        <td class="left">3</td>
                        <td class="left"><a href="#RST_STREAM" class="smpl">RST_STREAM</a></td>
                        <td class="left">-</td>
                        <td class="left"><a href="#RST_STREAM" title="RST_STREAM">Section&nbsp;6.4</a></td>
                     </tr>
                     <tr>
                        <td class="left">4</td>
                        <td class="left"><a href="#SETTINGS" class="smpl">SETTINGS</a></td>
                        <td class="left">ACK(1)</td>
                        <td class="left"><a href="#SETTINGS" title="SETTINGS">Section&nbsp;6.5</a></td>
                     </tr>
                     <tr>
                        <td class="left">5</td>
                        <td class="left"><a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a></td>
                        <td class="left">END_PUSH_PROMISE(4)</td>
                        <td class="left"><a href="#PUSH_PROMISE" title="PUSH_PROMISE">Section&nbsp;6.6</a></td>
                     </tr>
                     <tr>
                        <td class="left">6</td>
                        <td class="left"><a href="#PING" class="smpl">PING</a></td>
                        <td class="left">ACK(1)</td>
                        <td class="left"><a href="#PING" title="PING">Section&nbsp;6.7</a></td>
                     </tr>
                     <tr>
                        <td class="left">7</td>
                        <td class="left"><a href="#GOAWAY" class="smpl">GOAWAY</a></td>
                        <td class="left">-</td>
                        <td class="left"><a href="#GOAWAY" title="GOAWAY">Section&nbsp;6.8</a></td>
                     </tr>
                     <tr>
                        <td class="left">9</td>
                        <td class="left"><a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a></td>
                        <td class="left">-</td>
                        <td class="left"><a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">Section&nbsp;6.9</a></td>
                     </tr>
                     <tr>
                        <td class="left">10</td>
                        <td class="left"><a href="#CONTINUATION" class="smpl">CONTINUATION</a></td>
                        <td class="left">END_HEADERS(4)</td>
                        <td class="left"><a href="#CONTINUATION" title="CONTINUATION">Section&nbsp;6.10</a></td>
                     </tr>
                  </tbody>
               </table>
            </div>
         </div>
         <div>
            <h2 id="rfc.section.12.3"><a href="#rfc.section.12.3">12.3</a>&nbsp;Error Code Registry
            </h2>
            <p id="rfc.section.12.3.p.1">This document establishes a registry for HTTP/2.0 error codes. The "HTTP/2.0 Error Code" registry manages a 32-bit space.
               The "HTTP/2.0 Error Code" registry operates under the <a href="#RFC5226">"Expert Review" policy</a> <cite title="Guidelines for Writing an IANA Considerations Section in RFCs">[RFC5226]</cite>.
            </p>
            <p id="rfc.section.12.3.p.2">Registrations for error codes are required to include a description of the error code. An expert reviewer is advised to examine
               new registrations for possible duplication with existing error codes. Use of existing registrations is to be encouraged, but
               not mandated.
            </p>
            <p id="rfc.section.12.3.p.3">New registrations are advised to provide the following information: </p>
            <dl>
               <dt>Error Code:</dt>
               <dd>The 32-bit error code value.</dd>
               <dt>Name:</dt>
               <dd>A name for the error code. Specifying an error code name is optional.</dd>
               <dt>Description:</dt>
               <dd>A description of the conditions where the error code is applicable.</dd>
               <dt>Specification:</dt>
               <dd>An optional reference for a specification that defines the error code.</dd>
            </dl>
            <p id="rfc.section.12.3.p.4">An initial set of error code registrations can be found in <a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a>.
            </p>
         </div>
         <div>
            <h2 id="rfc.section.12.4"><a href="#rfc.section.12.4">12.4</a>&nbsp;Settings Registry
            </h2>
            <p id="rfc.section.12.4.p.1">This document establishes a registry for HTTP/2.0 settings. The "HTTP/2.0 Settings" registry manages a 24-bit space. The "HTTP/2.0
               Settings" registry operates under the <a href="#RFC5226">"Expert Review" policy</a> <cite title="Guidelines for Writing an IANA Considerations Section in RFCs">[RFC5226]</cite>.
            </p>
            <p id="rfc.section.12.4.p.2">Registrations for settings are required to include a description of the setting. An expert reviewer is advised to examine
               new registrations for possible duplication with existing settings. Use of existing registrations is to be encouraged, but
               not mandated.
            </p>
            <p id="rfc.section.12.4.p.3">New registrations are advised to provide the following information: </p>
            <dl>
               <dt>Setting:</dt>
               <dd>The 24-bit setting value.</dd>
               <dt>Name:</dt>
               <dd>A name for the setting. Specifying a name is optional.</dd>
               <dt>Flags:</dt>
               <dd>Any setting-specific flags that apply, including their value and semantics.</dd>
               <dt>Description:</dt>
               <dd>A description of the setting. This might include the range of values, any applicable units and how to act upon a value when
                  it is provided.
               </dd>
               <dt>Specification:</dt>
               <dd>An optional reference for a specification that defines the setting.</dd>
            </dl>
            <p id="rfc.section.12.4.p.4">An initial set of settings registrations can be found in <a href="#SettingValues" title="Defined Settings">Section&nbsp;6.5.2</a>.
            </p>
         </div>
         <div>
            <h2 id="rfc.section.12.5"><a href="#rfc.section.12.5">12.5</a>&nbsp;HTTP2-Settings Header Field Registration
            </h2>
            <p id="rfc.section.12.5.p.1">This section registers the <samp>HTTP2-Settings</samp> header field in the <a href="#BCP90">Permanent Message Header Field Registry</a> <cite title="Registration Procedures for Message Header Fields">[BCP90]</cite>. 
            </p>
            <dl>
               <dt>Header field name:</dt>
               <dd>HTTP2-Settings</dd>
               <dt>Applicable protocol:</dt>
               <dd>http</dd>
               <dt>Status:</dt>
               <dd>standard</dd>
               <dt>Author/Change controller:</dt>
               <dd>IETF</dd>
               <dt>Specification document(s):</dt>
               <dd><a href="#Http2SettingsHeader" title="HTTP2-Settings Header">Section&nbsp;3.2.1</a> of this document
               </dd>
               <dt>Related information:</dt>
               <dd>This header field is only used by an HTTP/2.0 client for Upgrade-based negotiation.</dd>
            </dl>
         </div>
      </div>
      <div>
         <h1 id="rfc.section.13"><a href="#rfc.section.13">13.</a>&nbsp;Acknowledgements
         </h1>
         <p id="rfc.section.13.p.1">This document includes substantial input from the following individuals: </p>
         <ul>
            <li>Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa Wilk, Costin Manolache, William Chan, Vitaliy Lvin, Joe
               Chan, Adam Barth, Ryan Hamilton, Gavin Peters, Kent Alstad, Kevin Lindsay, Paul Amer, Fan Yang, Jonathan Leighton (SPDY contributors).
            </li>
            <li>Gabriel Montenegro and Willy Tarreau (Upgrade mechanism)</li>
            <li>William Chan, Salvatore Loreto, Osama Mazahir, Gabriel Montenegro, Jitu Padhye, Roberto Peon, Rob Trace (Flow control)</li>
            <li>Mark Nottingham, Julian Reschke, James Snell, Jeff Pinner, Mike Bishop (Substantial editorial contributions)</li>
         </ul>
      </div>
      <h1 id="rfc.references"><a id="rfc.section.14" href="#rfc.section.14">14.</a> References
      </h1>
      <h2 id="rfc.references.1"><a href="#rfc.section.14.1" id="rfc.section.14.1">14.1</a> Normative References
      </h2>
      <table>
         <tr>
            <td class="reference"><b id="COMPRESSION">[COMPRESSION]</b></td>
            <td class="top">Ruellan, H. and R. Peon, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-03">HPACK - Header Compression for HTTP/2.0</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-header-compression-03 (work in progress), August&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p1">[HTTP-p1]</b></td>
            <td class="top">Fielding, R. and J. Reschke, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-24">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p1-messaging-24 (work in progress), September&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p2">[HTTP-p2]</b></td>
            <td class="top">Fielding, R. and J. Reschke, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-24">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p2-semantics-24 (work in progress), September&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p4">[HTTP-p4]</b></td>
            <td class="top"><a href="mailto:fielding@gbiv.com" title="Adobe Systems Incorporated">Fielding, R., Ed.</a> and <a href="mailto:julian.reschke@greenbytes.de" title="greenbytes GmbH">J. Reschke, Ed.</a>, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-24">Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p4-conditional-24 (work in progress), September&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p5">[HTTP-p5]</b></td>
            <td class="top"><a href="mailto:fielding@gbiv.com" title="Adobe Systems Incorporated">Fielding, R., Ed.</a>, <a href="mailto:ylafon@w3.org" title="World Wide Web Consortium">Lafon, Y., Ed.</a>, and <a href="mailto:julian.reschke@greenbytes.de" title="greenbytes GmbH">J. Reschke, Ed.</a>, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p5-range-24">Hypertext Transfer Protocol (HTTP/1.1): Range Requests</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p5-range-24 (work in progress), September&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p6">[HTTP-p6]</b></td>
            <td class="top"><a href="mailto:fielding@gbiv.com" title="Adobe Systems Incorporated">Fielding, R., Ed.</a>, <a href="mailto:mnot@mnot.net" title="Akamai">Nottingham, M., Ed.</a>, and <a href="mailto:julian.reschke@greenbytes.de" title="greenbytes GmbH">J. Reschke, Ed.</a>, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p6-cache-24">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p6-cache-24 (work in progress), September&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p7">[HTTP-p7]</b></td>
            <td class="top"><a href="mailto:fielding@gbiv.com" title="Adobe Systems Incorporated">Fielding, R., Ed.</a> and <a href="mailto:julian.reschke@greenbytes.de" title="greenbytes GmbH">J. Reschke, Ed.</a>, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p7-auth-24">Hypertext Transfer Protocol (HTTP/1.1): Authentication</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p7-auth-24 (work in progress), September&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2119">[RFC2119]</b></td>
            <td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, “<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2818">[RFC2818]</b></td>
            <td class="top">Rescorla, E., “<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>”, RFC&nbsp;2818, May&nbsp;2000.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC3986">[RFC3986]</b></td>
            <td class="top">Berners-Lee, T., Fielding, R., and L. Masinter, “<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>”, STD&nbsp;66, RFC&nbsp;3986, January&nbsp;2005.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC4648">[RFC4648]</b></td>
            <td class="top">Josefsson, S., “<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>”, RFC&nbsp;4648, October&nbsp;2006.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC5226">[RFC5226]</b></td>
            <td class="top">Narten, T. and H. Alvestrand, “<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>”, BCP&nbsp;26, RFC&nbsp;5226, May&nbsp;2008.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC5234">[RFC5234]</b></td>
            <td class="top">Crocker, D. and P. Overell, “<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>”, STD&nbsp;68, RFC&nbsp;5234, January&nbsp;2008.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC6454">[RFC6454]</b></td>
            <td class="top">Barth, A., “<a href="http://tools.ietf.org/html/rfc6454">The Web Origin Concept</a>”, RFC&nbsp;6454, December&nbsp;2011.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="TCP">[TCP]</b></td>
            <td class="top">Postel, J., “<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>”, STD&nbsp;7, RFC&nbsp;793, September&nbsp;1981.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="TLS-EXT">[TLS-EXT]</b></td>
            <td class="top">Eastlake, D., “<a href="http://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>”, RFC&nbsp;6066, January&nbsp;2011.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="TLS11">[TLS11]</b></td>
            <td class="top">Dierks, T. and E. Rescorla, “<a href="http://tools.ietf.org/html/rfc4346">The Transport Layer Security (TLS) Protocol Version 1.1</a>”, RFC&nbsp;4346, April&nbsp;2006.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="TLS12">[TLS12]</b></td>
            <td class="top">Dierks, T. and E. Rescorla, “<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>”, RFC&nbsp;5246, August&nbsp;2008.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="TLSALPN">[TLSALPN]</b></td>
            <td class="top">Friedl, S., Popov, A., Langley, A., and E. Stephan, “<a href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg-02">Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension</a>”, Internet-Draft&nbsp;draft-ietf-tls-applayerprotoneg-02 (work in progress), September&nbsp;2013.
            </td>
         </tr>
      </table>
      <h2 id="rfc.references.2"><a href="#rfc.section.14.2" id="rfc.section.14.2">14.2</a> Informative References
      </h2>
      <table>
         <tr>
            <td class="reference"><b id="BCP90">[BCP90]</b></td>
            <td class="top"><a href="mailto:GK-IETF@ninebynine.org" title="Nine by Nine">Klyne, G.</a>, <a href="mailto:mnot@pobox.com" title="BEA Systems">Nottingham, M.</a>, and <a href="mailto:JeffMogul@acm.org" title="HP Labs">J. Mogul</a>, “<a href="http://tools.ietf.org/html/rfc3864">Registration Procedures for Message Header Fields</a>”, BCP&nbsp;90, RFC&nbsp;3864, September&nbsp;2004.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RC4">[RC4]</b></td>
            <td class="top">Rivest, R., “The RC4 encryption algorithm”, RSA Data Security, Inc., March&nbsp;1992.</td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1323">[RFC1323]</b></td>
            <td class="top">Jacobson, V., Braden, B., and D. Borman, “<a href="http://tools.ietf.org/html/rfc1323">TCP Extensions for High Performance</a>”, RFC&nbsp;1323, May&nbsp;1992.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="TALKING">[TALKING]</b></td>
            <td class="top">Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, “<a href="http://w2spconf.com/2011/papers/websocket.pdf">Talking to Yourself for Fun and Profit</a>”, 2011, &lt;<a href="http://w2spconf.com/2011/papers/websocket.pdf">http://w2spconf.com/2011/papers/websocket.pdf</a>&gt;.
            </td>
         </tr>
      </table>
      <div class="avoidbreak">
         <h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
         <p><b>Mike Belshe</b><br>Twist<br>Email: <a href="mailto:mbelshe@chromium.org">mbelshe@chromium.org</a></p>
         <p><b>Roberto Peon</b><br>Google, Inc<br>Email: <a href="mailto:fenix@google.com">fenix@google.com</a></p>
         <p><b>Martin Thomson</b>
            (editor)
            <br>Microsoft<br>3210 Porter Drive<br>Palo Alto, 94304<br>US<br>Email: <a href="mailto:martin.thomson@skype.net">martin.thomson@skype.net</a></p>
         <p><b>Alexey Melnikov</b>
            (editor)
            <br>Isode Ltd<br>5 Castle Business Village<br>36 Station Road<br>Hampton, Middlesex&nbsp;TW12 2BX<br>UK<br>Email: <a href="mailto:Alexey.Melnikov@isode.com">Alexey.Melnikov@isode.com</a></p>
      </div>
      <div id="change.log">
         <h1 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a href="#change.log">Change Log (to be removed by RFC Editor before publication)</a></h1>
         <div id="changes.since.draft-ietf-httpbis-http2-06">
            <h2 id="rfc.section.A.1"><a href="#rfc.section.A.1">A.1</a>&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-06">Since draft-ietf-httpbis-http2-06</a></h2>
            <p id="rfc.section.A.1.p.1">Adding definition for CONNECT method.</p>
            <p id="rfc.section.A.1.p.2">Constraining the use of push to safe, cacheable methods with no request body.</p>
            <p id="rfc.section.A.1.p.3">Changing from :host to :authority to remove any potential confusion.</p>
            <p id="rfc.section.A.1.p.4">Adding setting for for header compression table size.</p>
            <p id="rfc.section.A.1.p.5">Adding settings acknowledgement.</p>
            <p id="rfc.section.A.1.p.6">Removing unnecessary and potentially problematic flags from CONTINUATION.</p>
         </div>
         <div id="changes.since.draft-ietf-httpbis-http2-05">
            <h2 id="rfc.section.A.2"><a href="#rfc.section.A.2">A.2</a>&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-05">Since draft-ietf-httpbis-http2-05</a></h2>
            <p id="rfc.section.A.2.p.1">Marking the draft ready for implementation.</p>
            <p id="rfc.section.A.2.p.2">Renumbering END_PUSH_PROMISE flag.</p>
            <p id="rfc.section.A.2.p.3">Editorial clarifications and changes.</p>
         </div>
         <div id="changes.since.draft-ietf-httpbis-http2-04">
            <h2 id="rfc.section.A.3"><a href="#rfc.section.A.3">A.3</a>&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-04">Since draft-ietf-httpbis-http2-04</a></h2>
            <p id="rfc.section.A.3.p.1">Added CONTINUATION frame for HEADERS and PUSH_PROMISE.</p>
            <p id="rfc.section.A.3.p.2">PUSH_PROMISE is no longer implicitly prohibited if SETTINGS_MAX_CONCURRENT_STREAMS is zero.</p>
            <p id="rfc.section.A.3.p.3">Push expanded to allow all safe methods without a request body.</p>
            <p id="rfc.section.A.3.p.4">Clarified the use of HTTP header fields in requests and responses. Prohibited HTTP/1.1 hop-by-hop header fields.</p>
            <p id="rfc.section.A.3.p.5">Requiring that intermediaries not forward requests with missing or illegal routing :-headers.</p>
            <p id="rfc.section.A.3.p.6">Clarified requirements around handling different frames after stream close, stream reset and <a href="#GOAWAY" class="smpl">GOAWAY</a>.
            </p>
            <p id="rfc.section.A.3.p.7">Added more specific prohibitions for sending of different frame types in various stream states.</p>
            <p id="rfc.section.A.3.p.8">Making the last received setting value the effective value.</p>
            <p id="rfc.section.A.3.p.9">Clarified requirements on TLS version, extension and ciphers.</p>
         </div>
         <div id="changes.since.draft-ietf-httpbis-http2-03">
            <h2 id="rfc.section.A.4"><a href="#rfc.section.A.4">A.4</a>&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-03">Since draft-ietf-httpbis-http2-03</a></h2>
            <p id="rfc.section.A.4.p.1">Committed major restructuring atrocities.</p>
            <p id="rfc.section.A.4.p.2">Added reference to first header compression draft.</p>
            <p id="rfc.section.A.4.p.3">Added more formal description of frame lifecycle.</p>
            <p id="rfc.section.A.4.p.4">Moved END_STREAM (renamed from FINAL) back to <a href="#HEADERS" class="smpl">HEADERS</a>/<a href="#DATA" class="smpl">DATA</a>.
            </p>
            <p id="rfc.section.A.4.p.5">Removed HEADERS+PRIORITY, added optional priority to <a href="#HEADERS" class="smpl">HEADERS</a> frame.
            </p>
            <p id="rfc.section.A.4.p.6">Added <a href="#PRIORITY" class="smpl">PRIORITY</a> frame.
            </p>
         </div>
         <div id="changes.since.draft-ietf-httpbis-http2-02">
            <h2 id="rfc.section.A.5"><a href="#rfc.section.A.5">A.5</a>&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-02">Since draft-ietf-httpbis-http2-02</a></h2>
            <p id="rfc.section.A.5.p.1">Added continuations to frames carrying header blocks.</p>
            <p id="rfc.section.A.5.p.2">Replaced use of "session" with "connection" to avoid confusion with other HTTP stateful concepts, like cookies.</p>
            <p id="rfc.section.A.5.p.3">Removed "message".</p>
            <p id="rfc.section.A.5.p.4">Switched to TLS ALPN from NPN.</p>
            <p id="rfc.section.A.5.p.5">Editorial changes.</p>
         </div>
         <div id="changes.since.draft-ietf-httpbis-http2-01">
            <h2 id="rfc.section.A.6"><a href="#rfc.section.A.6">A.6</a>&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-01">Since draft-ietf-httpbis-http2-01</a></h2>
            <p id="rfc.section.A.6.p.1">Added IANA considerations section for frame types, error codes and settings.</p>
            <p id="rfc.section.A.6.p.2">Removed data frame compression.</p>
            <p id="rfc.section.A.6.p.3">Added <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a>.
            </p>
            <p id="rfc.section.A.6.p.4">Added globally applicable flags to framing.</p>
            <p id="rfc.section.A.6.p.5">Removed zlib-based header compression mechanism.</p>
            <p id="rfc.section.A.6.p.6">Updated references.</p>
            <p id="rfc.section.A.6.p.7">Clarified stream identifier reuse.</p>
            <p id="rfc.section.A.6.p.8">Removed CREDENTIALS frame and associated mechanisms.</p>
            <p id="rfc.section.A.6.p.9">Added advice against naive implementation of flow control.</p>
            <p id="rfc.section.A.6.p.10">Added session header section.</p>
            <p id="rfc.section.A.6.p.11">Restructured frame header. Removed distinction between data and control frames.</p>
            <p id="rfc.section.A.6.p.12">Altered flow control properties to include session-level limits.</p>
            <p id="rfc.section.A.6.p.13">Added note on cacheability of pushed resources and multiple tenant servers.</p>
            <p id="rfc.section.A.6.p.14">Changed protocol label form based on discussions.</p>
         </div>
         <div id="changes.since.draft-ietf-httpbis-http2-00">
            <h2 id="rfc.section.A.7"><a href="#rfc.section.A.7">A.7</a>&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-00">Since draft-ietf-httpbis-http2-00</a></h2>
            <p id="rfc.section.A.7.p.1">Changed title throughout.</p>
            <p id="rfc.section.A.7.p.2">Removed section on Incompatibilities with SPDY draft#2.</p>
            <p id="rfc.section.A.7.p.3">Changed <a href="#INTERNAL_ERROR" class="smpl">INTERNAL_ERROR</a> on <a href="#GOAWAY" class="smpl">GOAWAY</a> to have a value of 2 &lt;<a href="https://groups.google.com/forum/?fromgroups#!topic/spdy-dev/cfUef2gL3iU">https://groups.google.com/forum/?fromgroups#!topic/spdy-dev/cfUef2gL3iU</a>&gt;.
            </p>
            <p id="rfc.section.A.7.p.4">Replaced abstract and introduction.</p>
            <p id="rfc.section.A.7.p.5">Added section on starting HTTP/2.0, including upgrade mechanism.</p>
            <p id="rfc.section.A.7.p.6">Removed unused references.</p>
            <p id="rfc.section.A.7.p.7">Added flow control principles (<a href="#fc-principles" title="Flow Control Principles">Section&nbsp;5.2.1</a>) based on &lt;<a href="http://tools.ietf.org/html/draft-montenegro-httpbis-http2-fc-principles-01">http://tools.ietf.org/html/draft-montenegro-httpbis-http2-fc-principles-01</a>&gt;.
            </p>
         </div>
         <div id="changes.since.draft-mbelshe-httpbis-spdy-00">
            <h2 id="rfc.section.A.8"><a href="#rfc.section.A.8">A.8</a>&nbsp;<a href="#changes.since.draft-mbelshe-httpbis-spdy-00">Since draft-mbelshe-httpbis-spdy-00</a></h2>
            <p id="rfc.section.A.8.p.1">Adopted as base for draft-ietf-httpbis-http2.</p>
            <p id="rfc.section.A.8.p.2">Updated authors/editors list.</p>
            <p id="rfc.section.A.8.p.3">Added status note.</p>
         </div>
      </div>
   </body>
</html>